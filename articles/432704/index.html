<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using an external wireless thermometer Buro H999 in conjunction with homemade devices</title>
  <meta name="description" content="Everyone is good weather station Buro H146G with an external wireless thermometer H999. But here only to see the readings on its black LCD display, go...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Using an external wireless thermometer Buro H999 in conjunction with homemade devices</h1><div class="post__text post__text-html js-mediator-article">  Everyone is good weather station Buro H146G with an external wireless thermometer H999.  But here only to see the readings on its black LCD display, good lighting is required.  And I would be better if the output of temperature and humidity outside the window was displayed on fairly bright indicators (for example, by combining the display of temperature and humidity with the clock on the gas-discharge indicators IN-12).  It is not hard to make such an article, but you need to know the protocol of exchange with a wireless thermometer.  There have already <a href="https://habr.com/post/275659/">been articles</a> on the use of a wireless thermometer weather stations to obtain temperature and humidity over the air.  But for Buro stations, the exchange protocol has not yet been described.  So, it is necessary to fix it: perhaps someone can come in handy. <br><a name="habracut"></a><br>  On the Internet, I did not find descriptions of the exchange protocol of the BURO stations.  And this means that you have to open the protocol of the exchange of the wireless sensor. <br><br>  My external thermometer looks like this: <br><br><img src="https://habrastorage.org/webt/o3/y4/ex/o3y4exet3g-ru6d1bdhpwrqiakm.jpeg"><br><br>  Having connected a Chinese superregenerative receiver at 433.92 MHz to the oscilloscope and pressing the TEST button on the thermometer, it was clearly visible how the transmission pulses were running.  Well, since the frequency there is small, the output of the receiver was connected to the input of the sound card through a resistive divider.  After processing the recorded sound file with a comparator, the following image was obtained: <br><br><img src="https://habrastorage.org/webt/kp/gh/sv/kpghsvyozbxt9dtkqfk4ap-f9hw.gif"><br><br>  Like other weather stations, modulation is performed by changing the duty cycle.  The transmission from the sync signal unit begins, then another sync signal goes, and then the data goes, followed by the final sync signal.  Two zeros after the clock signal, apparently, are the identifier of the beginning of the data - in any case, I have never noticed their changes.  Data with a start and end clock is duplicated six times.  Data exchange is conducted by nibbles. <br><br>  For decoding, I decided to start receiving on the first clock signal and two zeros, and finish on the last clock signal. <br><br>  In order to decode such a signal, it is sufficient to calculate the duration between signal drops. <br><br>  For this I wrote a simple test program for the Atmega8 controller: <br><br><div class="spoiler">  <b class="spoiler_title">Atmega8 software</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------------------------------------------------- //–±–∏–±–ª–∏–æ—Ç–µ–∫–∏ //---------------------------------------------------------------------------------------------------- #include &lt;avr/io.h&gt; #include &lt;util/delay.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;avr/pgmspace.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdint.h&gt; //---------------------------------------------------------------------------------------------------- //—á–∞—Å—Ç–æ—Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- #define F_CPU 8000000UL //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //–º–∞–∫—Ä–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //—Å–∫–æ—Ä–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö UART, –±–∏—Ç/—Å #define UART_SPEED 9600UL //---------------------------------------------------------------------------------------------------- //–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è //---------------------------------------------------------------------------------------------------- //—Ç–∏–ø –±–ª–æ–∫–∞ enum BLOCK_TYPE { BLOCK_TYPE_UNKNOW,//–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±–ª–æ–∫ BLOCK_TYPE_DIVIDER,//—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å BLOCK_TYPE_SYNCHRO,//—Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª BLOCK_TYPE_ONE,//–µ–¥–∏–Ω–∏—Ü–∞ BLOCK_TYPE_ZERO//–Ω–æ–ª—å }; //—Ä–µ–∂–∏–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è enum MODE { MODE_WAIT_SYNCHRO,//–æ–∂–∏–¥–∞–Ω–∏–µ —Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª–∞ MODE_WAIT_ZERO_FIRST,//–æ–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–≤–æ–≥–æ –Ω—É–ª—è MODE_WAIT_ZERO_SECOND,//–æ–∂–∏–¥–∞–Ω–∏–µ –≤—Ç–æ—Ä–æ–≥–æ –Ω—É–ª—è MODE_RECEIVE_DATA//–ø—Ä–∏—ë–º –¥–∞–Ω–Ω—ã—Ö }; //---------------------------------------------------------------------------------------------------- //–≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ //---------------------------------------------------------------------------------------------------- static const uint16_t MAX_TIMER_INTERVAL_VALUE=0xFFFF;//–º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ —Ç–∞–π–º–µ—Ä–∞ static volatile bool TimerOverflow=false;//–±—ã–ª–æ –ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ static uint8_t Buffer[20];//–±—É—Ñ–µ—Ä —Å–±–æ—Ä–∫–∏ –ø–æ–ª—É–±–∞–π—Ç–∞ static uint8_t BitSize=0;//–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–Ω—è—Ç—ã—Ö –±–∏—Ç static uint8_t Byte=0;//—Å–æ–±–∏—Ä–∞–µ–º—ã–π –±–∞–π—Ç //---------------------------------------------------------------------------------------------------- //–ø—Ä–æ—Ç–æ—Ç–∏–ø—ã —Ñ—É–Ω–∫—Ü–∏–π //---------------------------------------------------------------------------------------------------- void InitAVR(void);//–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ void UART_Write(unsigned char byte);//–ø–µ—Ä–µ–¥–∞—á–∞ —Å–∏–º–≤–æ–ª–∞ –≤ COM-–ø–æ—Ä—Ç void SendText(const char *text);//–æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ COM-–ø–æ—Ä—Ç void RF_Init(void);//–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è void RF_SetTimerOverflow(void);//—É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–ª–∞–≥ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞ void RF_ResetTimerOverflow(void);//—Å–±—Ä–æ—Å–∏—Ç—å —Ñ–ª–∞–≥ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞ bool RF_IsTimerOverflow(void);//–ø–æ–ª—É—á–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ uint16_t RF_GetTimerValue(void);//–ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ void RF_ResetTimerValue(void);//—Å–±—Ä–æ—Å–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value);//–ø–æ–ª—É—á–∏—Ç—å —Ç–∏–ø –±–ª–æ–∫–∞ void RF_AddBit(bool state);//–¥–æ–±–∞–≤–∏—Ç—å –±–∏—Ç –¥–∞–Ω–Ω—ã—Ö void RF_ResetData(void);//–Ω–∞—á–∞—Ç—å —Å–±–æ—Ä–∫—É –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode);//–∞–Ω–∞–ª–∏–∑ –±–ª–æ–∫–∞ //---------------------------------------------------------------------------------------------------- //–æ—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã //---------------------------------------------------------------------------------------------------- int main(void) { InitAVR(); _delay_ms(200); SendText("Thermo unit\r\n"); _delay_ms(200); sei(); while(1); cli(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //–æ–±—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- void InitAVR(void) { //–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–æ—Ä—Ç—ã DDRB=0; DDRD=0; DDRC=0; //–∑–∞–¥–∞—ë–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤ PORTB=0; PORTD=0; PORTC=0; //—É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∂–∏–º –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö UART UCSRB=(1&lt;&lt;RXEN)|(1&lt;&lt;TXEN)|(0&lt;&lt;RXCIE); //RXCIE=1 –∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω—ã (–±–∏—Ç I=1 –≤ —Ä–µ–≥–∏—Å—Ç—Ä–µ SREG) : –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é –ø—Ä–∏—ë–º–∞ –ø–æ UART —Ä–∞–∑—Ä–µ—à–µ–Ω–æ //TXCIE=1 –∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω—ã (–±–∏—Ç I=1 –≤ —Ä–µ–≥–∏—Å—Ç—Ä–µ SREG) : –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ UART —Ä–∞–∑—Ä–µ—à–µ–Ω–æ //UDRIE=1 –∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω—ã (–±–∏—Ç I=1 –≤ —Ä–µ–≥–∏—Å—Ç—Ä–µ SREG) : –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ –æ–ø—É—Å—Ç–æ—à–µ–Ω–∏—é —Ä–µ–≥–∏—Å—Ç—Ä–∞ –¥–∞–Ω–Ω—ã—Ö UART —Ä–∞–∑—Ä–µ—à–µ–Ω–æ //RXEN=1 : –∞–∫—Ç–∏–≤–∞—Ü–∏—è –ø—Ä–∏—ë–º–Ω–∏–∫–∞, –≤—ã–≤–æ–¥ D0 —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤—Ö–æ–¥–æ–º UART. //TXEN=1 : –∞–∫—Ç–∏–≤–∞—Ü–∏—è –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫–∞, –≤—ã–≤–æ–¥ D1 —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤—ã—Ö–æ–¥–æ–º UART. //CHR9=1 : –¥–ª–∏–Ω–∞ –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º–æ–π –ø–æ—Å—ã–ª–∫–∏ —Å —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ä–∞–≤–Ω–æ–π 11 –±–∏—Ç (9 –±–∏—Ç –¥–∞–Ω–Ω—ã—Ö + —Å—Ç–∞—Ä—Ç-—Å—Ç–æ–ø–æ–≤—ã–π –±–∏—Ç + —Å—Ç–æ–ø-–±–∏—Ç). //RXB8-—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–æ–ø-–±–∏—Ç //TXB8-—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å—Ç–æ–ø-–±–∏—Ç //–≤—ã—á–∏—Å–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥–∞—á–∏ –¥–∞–Ω–Ω—ã—Ö unsigned long speed=F_CPU/(16UL); speed=(speed/UART_SPEED)-1UL; UBRRH=(speed&gt;&gt;8)&amp;0xff; UBRRL=speed&amp;0xFF; RF_Init(); } //---------------------------------------------------------------------------------------------------- //–ø–µ—Ä–µ–¥–∞—á–∞ —Å–∏–º–≤–æ–ª–∞ –≤ COM-–ø–æ—Ä—Ç //---------------------------------------------------------------------------------------------------- void UART_Write(unsigned char byte) { while(!(UCSRA&amp;(1&lt;&lt;UDRE))); UDR=byte; } //---------------------------------------------------------------------------------------------------- //–æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç –≤ COM-–ø–æ—Ä—Ç //---------------------------------------------------------------------------------------------------- void SendText(const char *text) { while((*text)) { UART_Write(*text); text++; } } //---------------------------------------------------------------------------------------------------- //–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è //---------------------------------------------------------------------------------------------------- void RF_Init(void) { //–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∞–Ω–∞–ª–æ–≥–æ–≤—ã–π –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä ACSR=(0&lt;&lt;ACD)|(1&lt;&lt;ACBG)|(0&lt;&lt;ACO)|(0&lt;&lt;ACI)|(1&lt;&lt;ACIE)|(0&lt;&lt;ACIC)|(0&lt;&lt;ACIS1)|(0&lt;&lt;ACIS0); //ACD - –≤–∫–ª—é—á–µ–Ω–∏–µ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ (0 - –í–ö–õ–Æ–ß–Å–ù!) //ACBG - –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –Ω–µ–∏–Ω–≤–µ—Ä—Ç—Ä–∏—Ä—É—é—â–µ–º—É –≤—Ö–æ–¥—É –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ –≤–Ω—É—Ç—Ä—Ä–µ–Ω–Ω–µ–≥–æ –ò–û–ù'–∞ //ACO - —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (–≤—ã—Ö–æ–¥ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞) //ACI - —Ñ–ª–∞–≥ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ—Ç –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ //ACIE - —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π –æ—Ç –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ //ACIC - –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ –∫ —Å—Ö–µ–º–µ –∑–∞—Ö–≤–∞—Ç–∞ —Ç–∞–π–º–µ—Ä–∞ T1 //ACIS1,ACID0 - —É—Å–ª–æ–≤–∏–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ—Ç –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ //–Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä T1 –Ω–∞ —á–∞—Å—Ç–æ—Ç—É 31250 –ì—Ü TCCR1A=(0&lt;&lt;WGM11)|(0&lt;&lt;WGM10)|(0&lt;&lt;COM1A1)|(0&lt;&lt;COM1A0)|(0&lt;&lt;COM1B1)|(0&lt;&lt;COM1B0); //COM1A1-COM1A0 - —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã–≤–æ–¥–∞ OC1A //COM1B1-COM1B0 - —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤—ã–≤–æ–¥–∞ OC1B //WGM11-WGM10 - —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã —Ç–∞–π–º–µ—Ä–∞ TCCR1B=(0&lt;&lt;WGM13)|(0&lt;&lt;WGM12)|(1&lt;&lt;CS12)|(0&lt;&lt;CS11)|(0&lt;&lt;CS10)|(0&lt;&lt;ICES1)|(0&lt;&lt;ICNC1); //WGM13-WGM12 - —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã —Ç–∞–π–º–µ—Ä–∞ //CS12-CS10 - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–∫—Ç–æ–≤—ã–º —Å–∏–≥–Ω–∞–ª–æ–º (–≤—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º –¥–µ–ª–µ–Ω–∏—è —Ç–∞–∫—Ç–æ–≤—ã—Ö –∏–º–ø—É–ª—å—Å–æ–≤ –Ω–∞ 256 (—á–∞—Å—Ç–æ—Ç–∞ —Ç–∞–π–º–µ—Ä–∞ 31250 –ì—Ü)) //ICNC1 - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ö–µ–º–æ–π –ø–æ–¥–∞–≤–ª–µ–Ω–∏—è –ø–æ–º–µ—Ö –±–ª–æ–∫–∞ –∑–∞—Ö–≤–∞—Ç–∞ //ICES1 - –≤—ã–±–æ—Ä –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ñ—Ä–æ–Ω—Ç–∞ —Å–∏–≥–Ω–∞–ª–∞ –∑–∞—Ö–≤–∞—Ç–∞ TCNT1=0;//–Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ TIMSK|=(1&lt;&lt;TOIE1);//–ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—é —Ç–∞–π–º–µ—Ä–∞ (—Ç–∞–π–º–µ—Ä T1 —à–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–∏–±–∏—Ç–Ω—ã–π) } //---------------------------------------------------------------------------------------------------- //—É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ñ–ª–∞–≥ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- void RF_SetTimerOverflow(void) { cli(); TimerOverflow=true; sei(); } //---------------------------------------------------------------------------------------------------- //—Å–±—Ä–æ—Å–∏—Ç—å —Ñ–ª–∞–≥ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- void RF_ResetTimerOverflow(void) { cli(); TimerOverflow=false; sei(); } //---------------------------------------------------------------------------------------------------- //–ø–æ–ª—É—á–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- bool RF_IsTimerOverflow(void) { cli(); bool ret=TimerOverflow; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //–ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- uint16_t RF_GetTimerValue(void) { cli(); uint16_t ret=TCNT1; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //—Å–±—Ä–æ—Å–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞ //---------------------------------------------------------------------------------------------------- void RF_ResetTimerValue(void) { cli(); TCNT1=0; sei(); RF_ResetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //–ø–æ–ª—É—á–∏—Ç—å —Ç–∏–ø –±–ª–æ–∫–∞ //---------------------------------------------------------------------------------------------------- BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value) { static const uint32_t DIVIDER_MIN=(31250UL*12)/44100UL; static const uint32_t DIVIDER_MAX=(31250UL*25)/44100UL; static const uint32_t ZERO_MIN=(31250UL*80)/44100UL; static const uint32_t ZERO_MAX=(31250UL*100)/44100UL; static const uint32_t ONE_MIN=(31250UL*160)/44100UL; static const uint32_t ONE_MAX=(31250UL*200)/44100UL; static const uint32_t SYNCHRO_MIN=(31250UL*320)/44100UL; static const uint32_t SYNCHRO_MAX=(31250UL*400)/44100UL; if (counter&gt;DIVIDER_MIN &amp;&amp; counter&lt;DIVIDER_MAX) return(BLOCK_TYPE_DIVIDER);//—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å if (counter&gt;ZERO_MIN &amp;&amp; counter&lt;ZERO_MAX) return(BLOCK_TYPE_ZERO);//–Ω–æ–ª—å if (counter&gt;ONE_MIN &amp;&amp; counter&lt;ONE_MAX) return(BLOCK_TYPE_ONE);//–æ–¥–∏–Ω if (counter&gt;SYNCHRO_MIN &amp;&amp; counter&lt;SYNCHRO_MAX) return(BLOCK_TYPE_SYNCHRO);//—Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª return(BLOCK_TYPE_UNKNOW);//–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±–ª–æ–∫ } //---------------------------------------------------------------------------------------------------- //–¥–æ–±–∞–≤–∏—Ç—å –±–∏—Ç –¥–∞–Ω–Ω—ã—Ö //---------------------------------------------------------------------------------------------------- void RF_AddBit(bool state) { if ((BitSize&gt;&gt;2)&gt;=19) return;//–±—É—Ñ–µ—Ä –∑–∞–ø–æ–ª–Ω–µ–Ω Byte&lt;&lt;=1; if (state==true) Byte|=1; BitSize++; if ((BitSize&amp;0x03)==0) { Buffer[(BitSize&gt;&gt;2)-1]=Byte; Byte=0; } } //---------------------------------------------------------------------------------------------------- //–Ω–∞—á–∞—Ç—å —Å–±–æ—Ä–∫—É –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ //---------------------------------------------------------------------------------------------------- void RF_ResetData(void) { BitSize=0; Byte=0; } //---------------------------------------------------------------------------------------------------- //–∞–Ω–∞–ª–∏–∑ –±–ª–æ–∫–∞ //---------------------------------------------------------------------------------------------------- void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode) { //—É–∑–Ω–∞–µ–º —Ç–∏–ø –±–ª–æ–∫–∞ BLOCK_TYPE type=RF_GetBlockType(counter,value); if (type==BLOCK_TYPE_UNKNOW) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (type==BLOCK_TYPE_DIVIDER) return;//—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å –±–µ—Å–ø–æ–ª–µ–∑–µ–Ω –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ //–ø–æ—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è –∏ –∑–∞–≤–µ—Ä—à–∞—Ç—å—Å—è —Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª–æ–º if (mode==MODE_WAIT_SYNCHRO)//–∂–¥—ë–º —Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª–∞ { if (type==BLOCK_TYPE_SYNCHRO) { mode=MODE_WAIT_ZERO_FIRST; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (mode==MODE_WAIT_ZERO_FIRST || mode==MODE_WAIT_ZERO_SECOND)//–∂–¥—ë–º –¥–≤–∞ –Ω—É–ª—è { if (type==BLOCK_TYPE_SYNCHRO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) return;//–ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è —Å–∏–Ω—Ö—Ä–æ—Å–∏–≥–Ω–∞–ª if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) { mode=MODE_WAIT_ZERO_SECOND; return; } if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_SECOND) { mode=MODE_RECEIVE_DATA; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //–ø—Ä–∏–Ω–∏–º–∞–µ–º –¥–∞–Ω–Ω—ã–µ if (type==BLOCK_TYPE_SYNCHRO)//–ø—Ä–∏—ë–º –æ–∫–æ–Ω—á–µ–Ω { uint8_t size=(BitSize&gt;&gt;2); char str[30]; if (size!=10) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //–≤—ã–¥–∞—ë–º –±–ª–æ–∫ for(uint8_t n=0;n&lt;size;n++) { uint8_t b=Buffer[n]; uint8_t mask=(1&lt;&lt;3); for(uint8_t m=0;m&lt;4;m++,mask&gt;&gt;=1) { if (b&amp;mask) SendText("1"); else SendText("0"); } SendText(" "); } uint8_t channel=Buffer[2]&amp;0x03; uint8_t key=(Buffer[8]&gt;&gt;3)&amp;0x01; uint8_t h=(Buffer[7]&lt;&lt;4)|(Buffer[6]);//–≤–ª–∞–∂–Ω–æ—Å—Ç—å int16_t temp=(Buffer[5]&lt;&lt;8)|(Buffer[4]&lt;&lt;4)|(Buffer[3]);//—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ int16_t k=18; int16_t t=(10*(temp-1220))/k; sprintf(str,"%i",key); SendText("Key:"); SendText(str); sprintf(str,"%i",channel+1); SendText(" Ch:"); SendText(str); sprintf(str,"%i",h); SendText(" H:"); SendText(str); SendText("%, T:"); if (t&lt;0) { t=-t; sprintf(str,"-%i.%i",(int)(t/10),(int)(t%10)); } else { sprintf(str,"%i.%i",(int)(t/10),(int)(t%10)); } SendText(str); SendText(" C\r\n"); mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //–ø—Ä–∏—ë–º –¥–∞–Ω–Ω—ã—Ö if (type==BLOCK_TYPE_ONE) { RF_AddBit(true); return; } if (type==BLOCK_TYPE_ZERO) { RF_AddBit(false); return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤–µ–∫—Ç–æ—Ä–æ–≤ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //–æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–∫—Ç–æ—Ä–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞ T1 (16-–º–∏ —Ä–∞–∑—Ä—è–¥–Ω—ã–π —Ç–∞–π–º–µ—Ä) –ø–æ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—é //---------------------------------------------------------------------------------------------------- ISR(TIMER1_OVF_vect) { RF_SetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //–æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–∫—Ç–æ—Ä–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –æ—Ç –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ //---------------------------------------------------------------------------------------------------- ISR(ANA_COMP_vect) { ACSR&amp;=0xFF^(1&lt;&lt;ACIE);//–∑–∞–ø—Ä–µ—â–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è ACSR|=(1&lt;&lt;ACI);//—Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä–∞ static MODE mode=MODE_WAIT_SYNCHRO; //—É–∑–Ω–∞—ë–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ uint16_t length=RF_GetTimerValue(); if (RF_IsTimerOverflow()==true) length=MAX_TIMER_INTERVAL_VALUE;//–±—ã–ª–æ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ, —Å—á–∏—Ç–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º RF_ResetTimerValue(); //–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –∞–Ω–∞–ª–∏–∑ bool value=true; if (ACSR&amp;(1&lt;&lt;ACO)) value=false; RF_AnalizeCounter(length,value,mode); ACSR|=(1&lt;&lt;ACIE);//—Ä–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è }</span></span></code> </pre> <br></div></div><br>  The output of the receiver is connected to pin 13 (AIN1).  Atmega via max232 connects to the computer‚Äôs COM port (or to a USB-COM adapter).  The speed of the port is 9600 baud. <br><br>  After decoding, the following data stream will turn out (I throw two initial zeros): <br><br>  // no button, channel 1 <br>  1100 1100 0000 1110 1000 0110 1100 0001 0000 1001 Humidity: 28% Temperature: 25.4 <br>  // no button, channel 2 <br>  1100 1100 0001 1110 1000 0110 1101 0001 0000 0110 Humidity: 29% Temperature: 25.4 <br><br>  So the package looks like this: <br><br><img src="https://habrastorage.org/webt/dq/mj/iu/dqmjiuixxbenuwzxubzgfftypow.png"><br><br>  I0-I7 - thermometer identifier.  Each time the thermometer is turned on, the identifier changes. <br><br>  C0-C1 channel (there are 3 possible in total).  Channels are numbered from scratch. <br><br>  H0-H7 - humidity.  Humidity in percent is read as it is, but for some reason the temperature (T0-T11) is set in an unusual format for meteorological stations.  Judging by the descriptions of the exchange protocols of various meteorological stations found by me, one would expect a temperature in tenths of a degree and with a shift in the lower limit of the thermometer measurement.  So, no.  Experiments have shown that the temperature code of this weather station is converted to degrees Celsius as (T-1220) / 18.  From where these magic numbers are known only by the Chinese, who invented this exchange protocol. <br><br>  As the wolowizard suggested in the comments, the station transmits the temperature in tenths of degrees Fahrenheit, so a meaningful translation to Celsius will be 0.1 * (T-320) * 5 / 9-500 = 0.1 * (T-1220) /1.8. <br><br>  Bit K corresponds to pressing the TEST button. <br><br>  The assignment of the remaining fields could not be established, but it turned out that the value of the Fahrenheit / Celsius switch on the thermometer does not fall into the exchange protocol.  Presumably, the last nibble (and maybe the part of the last but one) is CRC, but I haven‚Äôt managed to calculate the algorithm yet (there is a suspicion that rows and nibbls are involved in the calculation).  If anyone can solve this riddle, please inform the calculation algorithm. <br>  For those who want to break their heads, but do not have such a thermometer, I provide a table of received data. <br><br><div class="spoiler">  <b class="spoiler_title">Table</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1001 0110 0101 1011 1000 0110 1000 0010 0001 1111 Key:0 Ch:2 H:40%, T:25.2 C 1001 1001 0000 1101 1010 0100 0101 0101 0000 0110 Key:0 Ch:1 H:85%, T:-1.2 C 1001 0110 0101 1100 1000 0110 1010 0010 0001 0100 Key:0 Ch:2 H:42%, T:25.3 C 1001 0110 1001 0110 0111 0110 1101 0001 0010 1111 Key:0 Ch:2 H:29%, T:24.1 C 1001 0110 1001 0000 0111 0110 1101 0001 0010 1000 Key:0 Ch:2 H:29%, T:23.7 C 1001 0110 1001 0010 0101 0110 1110 0001 0010 1111 Key:0 Ch:2 H:30%, T:22.1 C 1001 0110 1001 1001 0011 0110 1110 0001 0010 1100 Key:0 Ch:2 H:30%, T:20.7 C 1001 0110 1001 1111 0001 0110 1111 0001 0010 1010 Key:0 Ch:2 H:31%, T:19.2 C 1001 0110 0101 1001 0000 0110 0001 0010 0010 1000 Key:0 Ch:2 H:33%, T:18.0 C 1001 0110 0101 0010 1111 0101 0010 0010 0010 0111 Key:0 Ch:2 H:34%, T:16.7 C 1001 0110 0101 0100 1110 0101 0010 0010 0010 0010 Key:0 Ch:2 H:34%, T:16.0 C 1001 0110 0101 0100 1101 0101 0011 0010 0010 0001 Key:0 Ch:2 H:35%, T:15.1 C 1001 0110 0101 1100 1100 0101 0100 0010 0010 1110 Key:0 Ch:2 H:36%, T:14.6 C 1001 0110 0101 1111 1011 0101 0101 0010 0010 1111 Key:0 Ch:2 H:37%, T:13.9 C 1001 0110 0101 0011 1011 0101 0101 0010 0010 0001 Key:0 Ch:2 H:37%, T:13.2 C 1001 0110 0101 1001 1010 0101 0110 0010 0010 0101 Key:0 Ch:2 H:38%, T:12.7 C 1001 0110 0101 0100 1010 0101 0111 0010 0010 1000 Key:0 Ch:2 H:39%, T:12.4 C 1001 0110 0101 1011 1001 0101 0111 0010 0010 1010 Key:0 Ch:2 H:39%, T:11.9 C 1001 0110 0101 0011 1001 0101 1000 0010 0010 1001 Key:0 Ch:2 H:40%, T:11.5 C 1001 0110 0101 1011 1000 0101 1000 0010 0010 1110 Key:0 Ch:2 H:40%, T:11.0 C 1001 0110 0101 0111 1000 0101 1001 0010 0010 0101 Key:0 Ch:2 H:41%, T:10.8 C 1001 0110 0101 1111 0111 0101 1001 0010 0010 1101 Key:0 Ch:2 H:41%, T:10.3 C 1001 0110 0101 0111 0111 0101 1010 0010 0010 0111 Key:0 Ch:2 H:42%, T:9.9 C 1001 0110 0101 0001 0111 0101 1011 0010 0010 0101 Key:0 Ch:2 H:43%, T:9.6 C 1001 0110 0101 1011 0110 0101 1100 0010 0010 0110 Key:0 Ch:2 H:44%, T:9.2 C 1001 0110 0101 1000 0110 0101 1100 0010 0010 1100 Key:0 Ch:2 H:44%, T:9.1 C 1001 0110 0101 0011 0110 0101 1101 0010 0010 0110 Key:0 Ch:2 H:45%, T:8.8 C 1001 0110 0101 1001 0101 0101 1110 0010 0010 0110 Key:0 Ch:2 H:46%, T:8.2 C 1001 0110 0101 0101 0101 0101 1111 0010 0010 1101 Key:0 Ch:2 H:47%, T:8.0 C 1001 0110 0101 0010 0101 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.8 C 1001 0110 0101 1110 0100 0101 1111 0010 0010 0000 Key:0 Ch:2 H:47%, T:7.6 C 1001 0110 0101 1100 0100 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.5 C</code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/432704/">https://habr.com/ru/post/432704/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>