<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Detox and Appium: an automated interface test in React Native</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unfamiliar mobile environment 
 I, probably, like you, came to React Native as a developer of JavaScript rather than as a developer of native mobile a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Detox and Appium: an automated interface test in React Native</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xx/gv/pp/xxgvpps9vbr5q2jkamchgmd-quk.jpeg"><br><br><h3>  Unfamiliar mobile environment </h3><br>  I, probably, like you, came to React Native as a developer of JavaScript rather than as a developer of native mobile applications.  Absolutely new world with its own nuances and tricks. <br><br>  One of the most important topics to learn will be testing.  When everything is more or less clear with unit tests, what to do with interface tests and end-to-end tests?  iOS.  Android  On the market a mixture of different types of devices. <br><br>  Despite the fact that the technology itself is relatively new, it is still a mobile environment and you have to borrow and learn a lot from the native side. <br><br>  I will briefly review two frameworks that you should pay attention to make your life as a developer easier. <br><a name="habracut"></a><br><h3>  Appium </h3><br>  Using behind the scenes Selenium WebDriver, Appium is a powerful framework with a huge community of native mobile application developers.  Released before React.js, this is a leader and there is no equal to it. <br><br>  Getting started with Appium is pretty easy.  With the help of npm we install the ‚Äúappium‚Äù and ‚Äúappium-doctor‚Äù packages, we can globally, we can as part of the project.  The ‚Äúappium-doctor‚Äù team will tell us what else needs to be installed and configured before starting work, and, if possible, will help to correct the shortcomings.  When everything is solved, the packages are installed and the Jest configuration is in place, we can run the Appium server and tests. <br><br>  I will not go into the details of the settings, but this is how the simple test with the configuration looks like (comments are added): <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* –∫–ª–∏–µ–Ω—Ç selenium webdriver –¥–ª—è node */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wd <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'wd'</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 60 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç, –ø–æ—Å–ª–µ –∫–æ—Ç–æ—Ä—ã—Ö —Ç–µ—Å—Ç –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è, –µ—Å–ª–∏ –∑–∞—Å—Ç—Ä—è–Ω–µ—Ç */</span></span> jasmine.DEFAULT_TIMEOUT_INTERVAL = <span class="hljs-number"><span class="hljs-number">60000</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ Appium. –ó–∞–ø—É—Å–∫–∞–µ–º —Å –Ω–∞—à–µ–≥–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞, –ø–æ—ç—Ç–æ–º—É localhost */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">'localhost'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = <span class="hljs-number"><span class="hljs-number">4723</span></span> <span class="hljs-comment"><span class="hljs-comment">/* —Å–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç webdriver */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> driver = wd.promiseChainRemote(URL, PORT) <span class="hljs-comment"><span class="hljs-comment">/* –í–æ–∂–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä–∞. * –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –¥–ª—è —Å–µ—Ä–≤–µ—Ä–∞ Appium, * –∫–∞–∫ –∑–∞–ø—É—Å–∫–∞—Ç—å —Ç–µ—Å—Ç—ã, –¥—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> capabilities = { <span class="hljs-attr"><span class="hljs-attr">platformName</span></span>: <span class="hljs-string"><span class="hljs-string">'iOS'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// –∏–ª–∏ Android platformVersion: '12.1', // –≤–µ—Ä—Å–∏—è –û–° deviceName: 'iPhone 8', // –∏–ª–∏ ‚ÄúAndroid Emulator‚Äù –∏–ª–∏ —Ç–æ—á–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ automationName: 'XCUITest', // —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã (UIAutomator2 –¥–ª—è Android) app: '/path/to/.app' // —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ .app (–¥–ª—è Android —ç—Ç–æ .apk) } beforeAll(async () =&gt; { try { // –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç await driver.init(capabilities) // –∑–∞–ø—É—Å–∫–∞–µ–º –¥—Ä–∞–π–≤–µ—Ä await driver.sleep(4000) // –¥–∞ —É–∂, –≤—Ä—É—á–Ω—É—é —Å—Ç–∞–≤–∏–º —Ç–∞–π–º–µ—Ä –∏ –∂–¥–µ–º –∑–∞–≥—Ä—É–∑–∫—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –≤–æ—Ç –æ–Ω–∞ —Ö—Ä—É–ø–∫–æ—Å—Ç—å! } catch(err) { console.log(err) // –µ—Å–ª–∏ —á—Ç–æ, –º—ã —Ö–æ—Ç–∏–º –∑–Ω–∞—Ç—å, —á—Ç–æ –Ω–µ —Ç–∞–∫ } }) afterAll(async () =&gt; { try { await driver.quit() // –∫–æ–Ω–µ—Ü —Å–µ—Å—Å–∏–∏ } catch(err) { console.error(err) } }); /* Jest, –¥–µ–ª–∞–µ–º —á—Ç–æ —Ö–æ—Ç–∏–º, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç Appium! * –≤ –¥–∞–Ω–Ω–æ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–µ–∫—Å—Ç * 'topLabel' –∏ 'subLabel' –∑–∞–¥–∞–Ω–Ω–æ–º—É * –†–µ–∫–æ–º–µ–Ω–¥—É—é –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π –Ω–∞ —Å–∞–π—Ç–µ Appium */ describe("Home Screen landing", () =&gt; { test("render search screen", async () =&gt; { let topLabel = await driver.elementById('topLabel') let subLabel = await driver.elementById('subLabel') expect(await topLabel.text()).toBe("OK") expect(await subLabel.text()).toBe("–≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω") }) })</span></span></code> </pre> <br>  The test itself is the last few lines that check if the text ‚ÄúOK‚Äù and ‚Äúmain screen‚Äù are on the screen.  As you can see, the test is nothing special, the same Jest.  The documentation on the Appium site describes all the features of the framework, including also JavaScript examples. <br><br>  Dislike only the <code>await driver.sleep(4000)</code> string.  Unfortunately, tests have no idea what is happening in the application.  The so-called ‚Äúblack box‚Äù or Blackbox.  Imagine if you were writing code on Node, and before an http request, you would set a timer instead of using promise or callback.  Here it is, the fragility of UI tests. <br><br>  In this simple test, we wait 4 seconds to launch the application.  With time and with an increase in the number of tests, we will set timers more often - http requests, animation, React Native itself - the bridge between native code and JavaScript only complicates the situation. <br><br>  <i>"Black box", we have an application build without access to internal structures.</i> <br><img src="https://habrastorage.org/webt/pt/zs/cp/ptzscp_jlpii4ltt8ahqzhghtyq.png"><br><br>  <b>What do you like about Appium?</b> <br><br><ul><li>  7+ years in the industry. </li><li>  Extensive API. </li><li>  Easy to find help (this is also a minus, the list below) </li><li>  Multi-language support, including javascript. </li><li>  Familiar to the developer JavaScript jest environment. </li><li>  Used for end-to-end tests in MS AppCenter, BrowserStack and AWS DeviceFarm. </li><li>  The ability to test on these devices. </li></ul><br>  <b>What does not like in Appium</b> <br><br><ul><li>  An online search provides results for different programming languages, most of them Java. </li><li>  Testing the ‚Äúblack box‚Äù (tests do not know about the processes inside the application). </li><li>  No synchronicity with the application, fragility, even more problems are created by React Native. </li><li>  testID for some reason does not work on Android. </li></ul><br><br>  <i>Note three tabs: Appium server logs, metro bundler package and the test itself.</i> <br><img src="https://habrastorage.org/webt/ap/n-/pm/apn-pmr1nkmzno2m728ljq39tb8.png"><br><br><h3>  Detox </h3><br>  Wix's Detox works similarly to Appium.  The main difference is testing on the gray box strategy.  One of the tasks of the Detox developers was to solve the problems with fragility - the task in the application will not be started until the previous one is over and the application is not free.  This became possible thanks to another framework created under the name EarlGrey. <br><br>  Just as with Appium, we set the settings. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –≤ —Ñ–∞–π–ª–µ package.json, –Ω–∏–∂–µ –ø—Ä–∏–º–µ—Ä */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> detox = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"detox"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./package.json"</span></span>).detox; <span class="hljs-comment"><span class="hljs-comment">/* –∞–¥–∞–ø—Ç–µ—Ä Jest */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> adapter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"detox/runners/jest/adapter"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* –¢–∞–π–º–∞—É—Ç, * –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞–¥–∞–ø—Ç–µ—Ä–∞ Jest */</span></span> jest.setTimeout(<span class="hljs-number"><span class="hljs-number">120000</span></span>); jasmine.getEnv().addReporter(adapter); beforeAll(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> detox.init(config); }); <span class="hljs-comment"><span class="hljs-comment">/* beforeEach –∏ afterEach –¥–ª—è —Ç–µ—Å—Ç–æ–≤ Detox, * –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç Jest * —á–∏—Å—Ç–∏–º –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–æ–≤ */</span></span> beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> adapter.beforeEach(); }); afterAll(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> adapter.afterAll(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> detox.cleanup(); });</code> </pre><br>  And setting in package.json: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"detox"</span></span>: { <span class="hljs-string"><span class="hljs-string">"configurations"</span></span>: { <span class="hljs-string"><span class="hljs-string">"ios.detox"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è iOS (–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–æ–º–∞–Ω–¥–æ–π detox test -c ios.detox) "binaryPath": "path/to/.app", "build": "xcodebuild -workspace ios/app.xcworkspace -scheme scheme -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build", // —Ñ–∞–π–ª workspace –∏–ª–∏ project. –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —Å–æ–∑–¥–∞–µ–º –ø–∞–∫–µ—Ç debug –≤–º–µ—Å—Ç–æ production (release). "type": "ios.simulator", "name": "iPhone 8" // –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–∏–º—É–ª—è—Ç–æ—Ä–∞ }, "android.detox": { // –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è Android (–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–æ–º–∞–Ω–¥–æ–π detox test -c android.detox) "binaryPath": "path/to/.apk", "build": "cd android &amp;&amp; ./gradlew assembleDebug assembleAndroidTest -DtestBuildType=debug &amp;&amp; cd ..", // –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —Å–æ–∑–¥–∞–µ–º –ø–∞–∫–µ—Ç debug –≤–º–µ—Å—Ç–æ production (release). "type": "android.emulator", "name": "Pixel_2_API_28" // –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–∏–º—É–ª—è—Ç–æ—Ä–∞. ‚Äúadb devices‚Äù –ø–æ–∫–∞–∂–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ Android } }, "test-runner": "jest", "runner-config": { "setupTestFrameworkScriptFile" : "./detox.init.js", // –ø—Ä–∏–º–µ—Ä –≤—ã—à–µ "testEnvironment": "node", "testRegex": "(.*|\\.(ui))\\.(ts|tsx)$" // —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, –≥–¥–µ –∏—Å–∫–∞—Ç—å —Ç–µ—Å—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ } "specs": "./__tests__/" // —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ }</span></span></code> </pre><br>  Tests are as easy to write as for Appium, but using the capabilities and limitations of Detox. <br><br>  <i>"Gray box", we have the assembly of the application and access to internal structures.</i> <br><img src="https://habrastorage.org/webt/wb/eo/ox/wbeooxh72x0szw2op-lbixoeiow.png"><br><br>  <b>What I like about Detox</b> <br><br><ul><li>  Created by Wix for React Native. </li><li>  Focused on javascript. </li><li>  Test the strategy of the "gray box". </li><li>  Works synchronously with the application. </li></ul><br>  <b>What I don't like about Detox</b> <br><br><ul><li>  The possibilities are not as broad as those of Appium. </li><li>  Small community. </li></ul><br><h3>  Fragility </h3><br>  Despite the fact that Detox uses the gray box principle, fragility is still present.  The test with text input and svaypom did not work as it should in 1 case out of 10. You can not be 100% sure in the interface tests. <br><br><h3>  Speed </h3><br>  Appium ‚Äúslows down‚Äù the ‚Äú.sleep‚Äù timers set to manual, Detox in this case wins, because everything is synchronous.  In general, I would not draw any conclusions from my side, since I did not write a large number of identical tests on both platforms.  In 30-second tests and a simple test created for this article, Detox did a second faster.  If you look at two different platforms, iOS and Android, the tests took + - the same time.  The main thing to keep in mind is that interface tests take significantly longer unit tests. <br><br><h3>  What to choose </h3><br>  I still study both frameworks and it will take some time to understand all their advantages, but at the moment, as a JavaScript developer, I choose Detox. <br><br>  Try both, fortunately, there are only two.  It all depends on the application you are working on and the team. <br><br>  Interface tests in the development team - for developers, try Detox.  More sophisticated end-to-end tests - it may be better to take a closer look at Appium with its rich API capabilities and support on the BrowserStack, MS AppCenter and AWS DeviceFarm platforms. <br><br><h3>  Links </h3><br>  There are many useful resources and articles, but unfortunately, in English.  The first thing I recommend of.  sites. <br><br>  <a href="http://appium.io/">Appium</a> <br><br>  <a href="https://github.com/wix/Detox">Detox</a> </div><p>Source: <a href="https://habr.com/ru/post/434816/">https://habr.com/ru/post/434816/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>