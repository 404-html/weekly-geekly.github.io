<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservices make the world easier (and here and not)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About microservices now say everything. Almost every meeting, conference and mitap does not go without a story about what microservices are and how go...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <div class="page-header-logo-container"></div>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservices make the world easier (and here and not)</h1><div class="post__text post__text-html js-mediator-article">  About microservices now say everything.  Almost every meeting, conference and mitap does not go without a story about what microservices are and how good they are, how they reduce the complexity of a project and so on. <br><br>  The main message of all these reports is that microservices help to avoid the excessive complexity and complexity of the project.  But, as for me, it‚Äôs impossible not to get rid of the difficulty at all, you cannot redo the project so that everything at once becomes simple.  Difficulty from one area to another. <br><a name="habracut"></a><br>  For example: there was a very complicated tangled monolith, we broke it into several services, each of them looks great, anyone can deal with the code, but what happens to the environment?  Complexity grows: it is distributed transactions, which need to be logged so that it is a single transaction;  CI / CD and delivery are added for each service;  the interaction scheme becomes nontrivial. <br><br>  The most controversial theses or statements that I heard on the reports and with which I am ready to argue: <br><br>  <b>Entry to the monolith project is more expensive for new team members</b> .  For some reason, it is customary to estimate the cost of entering the project by how quickly the new developer will begin to do the tasks.  Yes, in a small service, he will figure it out very quickly and issue the task very quickly (especially according to the specification, ‚Äúwhat they wrote, then I did‚Äù). <br><br>  But what about the other team members? <br><br>  The new tester will deal with the integration model.  Testing a service is good, but in addition to testing a service contract, you need to check the business process that affects several services. <br><br>  At first, a new analyst can break his head at all, until he understands all the intricacies of internal challenges. <br><br>  <b>Microservices allow you to release more often</b> .  Microservices are updated faster, because they are separated into several parallel tasks that are being developed and tested in parallel, and all that remains is to check the integration (without taking into account time for analytics). <br><br>  You can also do this with a monolith, it all depends on the task decomposition.  Most often, at the very beginning there will be one task - to make the general functionality (to correct the common database, or to modify the interface), and then everyone will saw their subtasks and give them to testing. <br><br>  And the release time features, for which the business pays, will be the same.  The feature will be closed only when all components are released.  Microservices can solve 99% of tasks, but until the last feature closes, they will not be released into battle. <br><br><h2>  What else do not speak </h2><br><h4>  Complexity grows </h4><br>  When using microservices, the <b>infrastructure becomes more complex</b> .  This is due to the fact that it is necessary to support the work of not one application, but a multitude of services.  It is necessary to monitor the performance of all services, to understand well the dependencies of services by version, to have CI / CD plans for assembling services and delivery, and mechanisms for responding to service outputs out of order so that everything else does not fall. <br><br>  It seems to be simple things, and in the monolith we must do the same.  Only in the monolith we work on one application, and with the increase in the number of services, the complexity grows, which requires higher skills from support. <br><br>  <b>Microservices add complexity</b> - new libraries, new functionality to support distributed transactions, to handle errors of other services, send repeated requests, rollback transactions.  For the most part, these mechanisms will be common, and most developers will not get into the "guts", but will only use them. <br><br>  But they may also contain errors that will have to be repaired.  If we can handle the fix without problems, then it will take time and advanced controls to roll out the changes across 200‚Äì300 services.  And if you need to rebuild services with an updated library, or even redo the challenges (they fixed it, didn‚Äôt foresee it), then all this will not be fun. <br><br><h4>  Monolith is not a big ball of mud </h4><br>  How usually begin stories about the wonderful world of microservices?  ‚ÄúWe had a monolith, it was a solid clump of dirt, in which everything is confusing and incomprehensible,‚Äù plus another terrible picture will be shown.  And the monolith has already become something frightening, ‚Äúyou will work badly, your project will turn into a monolith‚Äù.  <b>But no.</b> <br><br>  A monolith can be (and should) be understandable, structured, with a 'good' code, with documentation, as well as a microservice project can turn into an even bigger clump of dirt if you do not engage in development processes and do not monitor the quality of development. <br><br><h2>  So what to use? </h2><br>  Good question, and you can only answer.  Because only you know what business problems you decide, what the project will be like.  There is no silver bullet, there is no ideal architecture that can be used and there will always be ‚Äúhappiness‚Äù. <br><br>  And in the monolith, and in microservices, follow the documentation and keep it up to date.  The documentation is better than without it. <br><br>  Build a development process in which the quality of the code will only increase (review, unit tests).  But about the quality you can write a whole book, this is a topic for a separate big conversation. <br><br>  Simple and understandable code is not about microservices, a code should be a priori. <br><br>  Test automation is also about the quality of the code. <br><br>  Automate everything that can be automated - CI / CD.  Probably, there is such a stack of technologies that is very difficult to tighten in the CI / CD, but 99% of the assemblies / supplies can be automated. </div><p>Source: <a href="https://habr.com/ru/post/427953/">https://habr.com/ru/post/427953/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>