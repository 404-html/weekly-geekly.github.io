<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>EHCI in Russian</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 All welcome. Today I want to share my experience and yet, in my opinion, I can clearly explain about this, at first glance, simple stan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <div class="page-header-logo-container"></div>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>EHCI in Russian</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="image"><br><br><h3>  <b>Introduction</b> </h3><br>  All welcome.  Today I want to share my experience and yet, in my opinion, I can clearly explain about this, at first glance, simple standard for a USB 2.0 host controller. <br><br>  Initially, you can imagine that the USB 2.0 port is just 4 pins, two of which simply transfer data (Like, for example, the COM port), but in fact everything is wrong, and even quite the opposite.  In principle, the USB controller does not allow us to transfer data through a normal COM port.  EHCI is a rather intricate standard that allows you to ensure reliable and fast data transfer from the software to the device itself, and in the opposite direction. <br><br>  Perhaps this article is useful to you if, for example, you do not have sufficient skills in writing drivers and reading the documentation for the hardware.  A simple example: if you want to write your own OS for a mini-PC, so that some kind of Windows or another Linux distribution will not load hardware, and you will use all its power solely for your own purposes. <br><a name="habracut"></a><br><h3>  <b>What is EHCI</b> </h3><br>  Well, let's get started.  EHCI - Enhanced Host Controller Interface, is designed to transfer data and control requests to USB-devices, and in the other direction, and in 99% of cases - is a link between any software and a physical device.  EHCI works as a PCI device, and accordingly uses MMIO (Memory-Mapped-IO) to control the controller (yes, I know that some PCI devices use ports, but then I summarized everything).  The documentation from Intel describes only the principle of operation, and there are no hints at all of the algorithms written at least in pseudo-code.  EHCI has 2 types of MMIO registers: Capability and Operational.  The former serve to obtain the characteristics of the controller, while the latter serve to control it.  Actually, I will attach the very essence of the connection between the software and the EHCI controller: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="image"><br><br>  Each EHCI controller has several ports, each of which can be connected to any USB-devices.  Also, please note that EHCI is an improved version of UHCI, which was also developed by Intel several years earlier.  For backward compatibility, any UHCI / OHCI controller that has a version lower than the EHCI will be a companion to the EHCI.  For example, you have a USB keyboard (most of the keyboards of the year have been like that until now), which works on USB 1.1 (note that the maximum speed of USB 1.1 is 12 megabits per second, and FullSpeed ‚Äã‚ÄãUSB 2.0 has bandwidth as much as 480 Mb / s), and you have a computer with a USB 2.0 port, when the keyboard is connected to the computer, the EHCI host controller no matter how it works with USB 1.1.  This model is shown in the following diagram: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="image"><br><br>  Also for the future I want to immediately warn that your driver may not work correctly because of such a ridiculous situation: you initialized the UHCI, and then the EHCI, added two identical devices, put the Port Owner Control bits in the port register, and then UHCI stopped working, because the EHCI automatically pulls the port to itself, and the port on the UHCI stops responding, this situation must be monitored. <br><br>  Also, let's take a look at a diagram showing the EHCI architecture itself: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="image"><br><br>  On the right is written about the queue - about them later. <br><br><h2>  EHCI controller registers </h2><br>  To begin with, I would like to clarify once again that through these registers you will control your device, therefore they are very important - and without them, EHCI programming is impossible. <br><br>  First you need to get the address of the MMIO, which is issued to this controller, at the offset + 0x10 will be the address of our long-awaited registers.  There is one thing: first, the Capability registers go, and only after them - the Operational, so at offset 0 (from the previous address, which we received at offset 0x10 relative to the start of the EMI of our EHCI MMI) there is one byte - the length of the Capability registers. <br><br><h3>  <b>Capability registers</b> </h3><br>  At offset 2, the <b>HCIVERSION</b> register is <b>located</b> - the revision number of this HC, which occupies 2 bytes and contains the BCD version of the revision (what BCD can be learned from Wikipedia). <br>  At offset +4 lies the <b>HCSPARAMS</b> register, its size is 2 words, it contains the structural parameters of the device and its bits show the following: <br><br><ul><li>  Bit 16 - Port Indicators - Available LEDs for connected USB devices. </li><li>  Bits 15:12 is the number of the companion controller that is assigned to this controller </li><li>  Bits 11: 8 - the number of ports in the companion controller </li><li>  Bit 7 - Port Routing Rules - shows how these ports are tied to companion ports </li><li>  Bit 4 - Port Power Control - shows whether it is necessary to turn on the power for each port, 0 - power is automatically supplied </li><li>  Bits 3: 0 - the number of ports in this controller. </li><li>  At offset +8, the HCCPARAMS register is located ‚Äî it shows the compatibility parameters, its bits mean the following: </li><li>  Bit 2 - the availability of the asynchronous queue </li><li>  Bit 1 - periodic (sequential) queue availability </li><li>  Bit 0 - 64-bit compatibility </li></ul><br><h3>  <b>Operation registers</b> </h3><br>  At offset 0, the <b>USBCMD</b> register is the command register of the controller, its bits mean the following: <br><br><ul><li>  Bits 23:16 - Interrupt Threshold Control - shows how many micro-frames will be used per regular frame.  The more, the faster, but if more than 8 - then the micro-frames will be processed with the same speed as for 8. </li><li>  Bit 6 - interrupt after each transaction in the asynchronous queue, </li><li>  Bit 5 - is the asynchronous queue used, </li><li>  Bit 4 - use sequential queue, </li><li>  Bits 3: 2 - FrameList'a size (about this - further).  0 means 1024 elements, 1 - 512, 2 - 256, 3 - reserved </li><li>  Bit 1 ‚Äî Set to perform a host controller reset. </li><li>  Bit 0 - Run / Stop </li></ul>  . <br>  Next, by offset +4, the register is <b>USBSTS</b> - the statute of the host controller, <br><br><ul><li>  Bit 15 indicates whether an asynchronous queue is being used. </li><li>  Bit 14 indicates whether a sequential queue is being used, </li><li>  Bit 13 ‚Äî Indicates an empty asynchronous queue is detected, </li><li>  Bit 12 is set to 1, if an error occurs while processing a transaction, then the host controller will stop all queues. </li><li>  Bit 4 is set to 1, if a serious error occurs, the host controller stops all queues. </li><li>  Bit 3 FrameList (Register) Rollover - set to 1 when the host controller has processed the entire frameList. </li><li>  Bit 1 - USB Error Interrupt - generate an error interrupt? </li><li>  Bit 0 - USB Interrupt - set after successful transaction processing, if IOC was set in TD </li></ul> <br>  Not tired?  You can pour yourself a strong tea and bring livers, we are still at the very beginning! <br><br>  At offset +8 is a register <b>USBINTR</b> - register enable interrupts <br>  In order not to write for a long time, and even more so, you don‚Äôt have to read for a long time, the bit values ‚Äã‚Äãof this register can be viewed in the specification, a link to it will be left below.  Here I just write down 0, because  I absolutely have no desire to write handlers, interrupt interrupts, etc., so I think this is almost absolutely pointless. <br><br>  At offset +12 (0x0C) lies the <b>FRINDEX</b> register, which simply contains the current frame number, and I want to note that the last 4 bits indicate the micro frame number, and in the older 28 bits the frame number (the value is not necessarily smaller than frameList ‚ÄúBut if you need an index, it's better to take it with a mask of 0x3FF (or 0x1FF, etc.). <br><br>  The <b>CTRLDSSEGMENT</b> register is at offset + 0x10, it shows the host controller the upper 32 bits of the frame sheet address. <br><br>  The <b>PERIODICLISTBASE</b> register has an offset of + 0x14, in which you can put the lower 32 bits of the frame sheet, note that the address must be aligned to the size of the memory page (4096). <br><br>  The <b>ASYNCLISTADDR</b> register has an offset + 0x18, in it you can put the address of the asynchronous queue, note that it must be aligned at the 32-byte boundary, while it must be in the first four gigabytes of physical memory. <br><br>  The <b>CONFIGFLAG</b> register indicates whether the device is configured.  You must set the bit 0 after the device is configured, it has an offset + 0x40. <br><br>  We turn to the port registers.  Each port has its own command-status register, each port register is located at <b>+ 0x44 +</b> offset <b>(PortNumber - 1) * 4</b> , its bits mean the following: <br><br><ul><li>  Bit 12 - port power, 1 - power is supplied, 0 - no. </li><li>  Bit 8 - Port Rest - is set to reset the device. </li><li>  Bit 3 - Port Enable / Disable Change - is set when the port is turned on. </li><li>  Bit 2 - Port Enabled / Not Enabled. </li><li>  Bit 1 - Change the connection status, put in 1, for example, if you connected or disconnected the USB device. </li><li>  Bit 0 - connection status, 1 - connected, 0 - no. </li></ul><br>  We now turn to the juice. <br><br><h2>  Transmission and query structures </h2><br>  The organization structure for processing requests includes queue and transfer descriptors (TDs). <br><br>  At the moment we will consider only 3 structures. <br><br><h3>  Sequential list </h3><br>  The consecutive (Periodic, Pereodic) list is arranged as follows: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="image"><br><br>  As can be seen in the diagram, processing begins with getting the required frame from the frame of the sheet, each of its elements takes 4 bytes and has the following structure: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="image"><br><br>  As you can see in the picture, the queue address / descriptor transfer is aligned at 32 bytes, bit 0 means that the host controller will not process this element, bits 3: 1 indicate the type of what the host controller will handle: 0 - isosynchronous TD (iTD), 1 - turn, 2 and 3 in this article I will not consider. <br><br><h3>  Asynchronous queue </h3><br>  The host controller processes this queue only when the frame is consecutive empty, or the host controller has processed the entire sequential list. <br><br>  An asynchronous queue is a pointer to a queue that contains other queues that need to be processed.  Scheme: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="image"><br><br><h3>  qTD (Queue Element Transfer Descriptor) </h3><br>  This TD has the following structure: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="image"><br><br>  <b>Next qTD Pointer</b> - a pointer to the continuation of the queue for processing (for Horizontal Execution), bit 0 Next qTD Pointer shows that there is no further queue anymore. <br>  <b>qTD Token</b> - TD token, shows data transfer parameters: <br><br><ul><li>  Bit 31 - Data Toggle (more on that later) </li><li>  Bits 30:16 - the amount of data to transfer, after the completion of the transaction, their value is reduced by the amount of transmitted data. </li><li>  Bit 15 - IOC - Interrupt On Complete - cause an interrupt after the handle has finished processing. </li><li>  Bits 14:12 show the number of the current buffer, to which / from which data is exchanged, about this later. </li><li>  Bits 11:10 - allowable number of errors.  This table shows when the error count decreases: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="image"><br><br>  Footnote 1 - Babble or Stall detection automatically stops execution of the queue head.  Footnote 3 - Data buffer errors are problems with the host.  They do not take into account device retries. </li><li>  9: 8 - PID Code - token type: 0 - input token (from host to device), 1 - output token (from device to host), 2 - ‚ÄúSETUP‚Äù token </li><li>  Bits 7: 0 indicate TD status: <br>  Bit 7 indicates that the TD has an active state (i.e., the host controller is processing the TD) <br>  Bit 6 - Halted - indicates that an error has occurred and TD execution has stopped. <br>  Bit 4 - Babble Detected - the amount of data that we sent to the device, or vice versa, is less than we transmit, that is, for example, the device sent us 100 bytes of data, and we read only 50 bytes, and then 50 more The Halted bit will also be set if this bit is set to 1. <br>  Bit 3 - Transaction Error - an error occurred during the transaction. </li></ul><br>  <b>qTD Buffer Page Pointer List</b> - any of 5 buffers.  Contains a link to where to make a transaction in memory (send data to the device / accept data from the device), all addresses in the buffers, except the first, should be aligned to the page size (4096 bytes). <br><br><h3>  Head queue </h3><br>  The Queue Head has the following structure: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="image"><br><br>  <b>Queue Head Horizontal Link Pointer</b> - pointer to the next queue, bits 2: 1 have the following values ‚Äã‚Äãdepending on the type of queue: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="image"><br><br>  <b>Endpoint Capabilities / Characteristics</b> - queue characteristics: <br><br><ul><li>  Bits 26:16 contain the maximum packet size for transmission </li><li>  Bit 14: Data Toggle Control - indicates where the host controller should take the initial Data Toggle value, 0 - ignores the DT bit in qTD, stores the DT bit for the head of the queue. </li><li>  Bit 13:12 - transmission rate characteristics: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="image"></li><li>  Bits 11: 8 - the number of the end point to which the request is made </li><li>  Bits 6: 0 - device address </li></ul><br>  <b>Endpoint Capabilities: Queue Head DWord 2</b> - continuation of the previous double word: <br><br><ul><li>  Bits 29:23 - Hub number </li><li>  Bits 22:16 - Address of the Hub </li></ul><br>  <b>Current qTD Link Pointer</b> - pointer to the current qTD. <br><br>  We turn to the most interesting. <br><br><h2>  EHCI driver </h2><br>  To begin with, what kind of requests can EHCI perform.  There are 2 types of requests: Control - a la commands, and Bulk - to the endpoints, for data exchange, for example, the absolute majority of USB flash drives (USB MassStorage) use the Bulk / Bulk / Bulk data transfer type.  The mouse and keyboard for data transmission also use Bulk - requests. <br><br>  We initialize EHCI and configure asynchronous and sequential queues: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register // –ß–∏—Ç–∞–µ–º –∫–æ–º–∞–Ω–¥–Ω—ã–π —Ä–µ–≥–∏—Å—Ç—Ä uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –µ–≥–æ –æ–±—Ä–∞—Ç–Ω–æ, –≤—ã—Å—Ç–∞–≤–ª—è—è –±–∏—Ç 2(Reset) // and making sure the two schedule Enable bits are clear. // –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ 2 –æ—á–µ—Ä–µ–¥–∏ –≤—ã–∫–ª—é—á–µ–Ω—ã WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –Ω–µ–ø–ª–æ—Ö–∞, –í—ã –Ω–µ –¥–æ–ª–∂–Ω—ã —á–∏—Ç–∞—Ç—å // the register before it has a chance to actually set the bit // —Ä–µ–≥–∏—Å—Ç—Ä –ø–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ —É –Ω–µ–≥–æ –Ω–µ –ø–æ—è–≤–∏—Ç—Å—è —à–∞–Ω—Å–∞ –≤—ã—Å—Ç–∞–≤–∏—Ç—å –±–∏—Ç ROR(usbCmdO); // Now wait for the controller to clear the reset bit. // –ñ–¥–µ–º –ø–æ–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä —Å–±—Ä–æ—Å–∏—Ç –±–∏—Ç Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. // –û–ø—è—Ç—å –∑–∞–¥–µ—Ä–∂–∫–∞ ROR(usbCmdO); // wait for the halted bit to become set // –ñ–¥–µ–º –ø–æ–∫–∞ –±–∏—Ç Halted –Ω–µ –±—É–¥–µ—Ç –≤—ã—Å—Ç–∞–≤–ª–µ–Ω while (!(ROR(usbStsO) &amp; STS_HCHALTED)); // –í—ã–¥–µ–ª—è–µ–º –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Ñ—Ä–µ–π–º –ª–∏—Å—Ç, –ø—É–ª –¥–ª—è –æ—á–µ—Ä–µ–¥–µ–π –∏ –ø—É–ª –¥–ª—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–æ–≤ // –ó–∞–º–µ—á—É, —á—Ç–æ –≤—Å–µ –º–æ–∏ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ã –∏ —ç–ª–µ–º–µ–Ω—Ç—ã –æ—á–µ—Ä–µ–¥–∏ –≤—ã—Ä–∞–≤–Ω–µ–Ω—ã –Ω–∞ –≥—Ä–∞–Ω–∏—Ü—É 128 –±–∞–π—Ç hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –æ—á–µ—Ä–µ–¥—å EhciQH *qh = EhciAllocQH(hc); // –≠—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω–∞—à—É –æ—á–µ—Ä–µ–¥—å, –æ–Ω–∞ —É –Ω–∞—Å –±—É–¥–µ—Ç –æ–¥–Ω–∞ // —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ —ç—Ç–æ –æ—á–µ—Ä–µ–¥—å qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; // —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –±–∏—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ —ç—Ç–æ –ì–æ–ª–æ–≤–∞ –æ—á–µ—Ä–µ–¥–∏ qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; // –ó–∞–ø–æ–ª–Ω—è–µ–º –±—É—Ñ–µ—Ä—ã –Ω—É–ª—è–º–∏ for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—É—é –æ—á–µ—Ä–µ–¥—å qh = EhciAllocQH(hc); // –ú—ã –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; // –ó–∞–ø–æ–ª–Ω—è–µ–º –±—É—Ñ–µ—Ä—ã for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; // –ó–∞–ø–æ–ª–Ω—è–µ–º —Ñ—Ä–µ–π–º–ª–∏—Å—Ç —Å—Å—ã–ª–∫–∞–º–∏ –Ω–∞ –Ω–∞—à—É –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—É—é –æ—á–µ—Ä–µ–¥—å for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities // –û—Ç–∫–ª—é—á–∞–µ–º BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts // –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ñ—Ä–µ–π–º–ª–∏—Å—Ç //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); // –∫–æ–ø–∏—Ä—É–µ–º –∞–¥—Ä–µ—Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–π –æ—á–µ—Ä–µ–¥–∏ –≤ —Ä–µ–≥–∏—Å—Ç—Ä //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–µ–≥–º–µ–Ω—Ç –≤ 0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status // –ß–∏—Å—Ç–∏–º —Å—Ç–∞—Ç—É—Å //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä, 8 –º–∏–∫—Ä–æ-—Ñ—Ä–µ–π–º–æ–≤, –≤–∫–ª—é—á–∞–µ–º // –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—É—é –∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—É—é –æ—á–µ—Ä–µ–¥—å //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // –ì–æ–≤–æ—Ä–∏–º, —á—Ç–æ –∑–∞–≤–µ—Ä—à–∏–ª–∏ //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices // –ü—Ä–æ–±—É–µ–º –ø–æ—Ä—Ç—ã EhciProbe(hc);</span></span></code> </pre> <br>  Actually, the code to reset the port to its original state: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">// –í–∫–ª—é—á–∞–µ–º –ø–∏—Ç–∞–Ω–∏–µ –Ω–∞ –ø–æ—Ä—Ç—É, –∂–¥—ë–º 100–º—Å *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Ä—Ç, –∂–¥–µ–º 50 –º—Å EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) // –ñ–¥–µ–º 100 –º—Å —á—Ç–æ–±—ã –ø–æ—Ä—Ç –≤–∫–ª—é—á–∏–ª—Å—è, –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–∞–ø–∏—Å–∞–Ω–æ, // —á—Ç–æ 100 –º—Å –¥–æ–ª–∂–Ω–æ —Ö–≤–∞—Ç–∏—Ç—å uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å status = *reg; // Check if device is attached to port // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∫ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—É if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status // –ï—Å–ª–∏ —Å—Ç–∞—Ç—É—Å –ø–æ–º–µ–Ω—è–ª—Å—è - —á–∏—Å—Ç–∏–º –±–∏—Ç—ã –ø–æ—Ä—Ç–∞ if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–∞ —Ç–æ, —á—Ç–æ –æ–Ω–æ –∑–∞–ø—É—Å—Ç–∏–ª–æ—Å—å if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Control request to the device: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties // –û–±–æ–∑–Ω–∞—á–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors // –°–æ–∑–¥–∞—ë–º –æ—á–µ—Ä–µ–¥—å TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—â–∏–π –ø–∞–∫–µ—Ç uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—É—Å td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–æ–ª–æ–≤—É –æ—á–µ—Ä–µ–¥–∏: EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed // –ñ–¥–µ–º –ø–æ–∫–∞ –æ—á–µ—Ä–µ–¥—å –Ω–µ –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  Queue processing code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  And now the request to the end point (Bulk-request) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties // –û–±–≥–æ–≤–∞—Ä–∏–≤–∞–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–æ–ª–æ–≤—É –æ—á–µ—Ä–µ–¥–∏ EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  I think that the topic is quite interesting, there are almost no documents, descriptions and articles on this topic on the Internet, and if there is, it is very vague.  If you are interested in the topic of working with hardware and OS development, then there is a lot to say. <br><br>  Docks: <a href="https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/ehci-specification-for-usb.pdf">Specification</a> </div><p>Source: <a href="https://habr.com/ru/post/426421/">https://habr.com/ru/post/426421/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>