<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I study Rust: How I made the game "Snake"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently I began to learn the programming language Rust and since when I study a new language I make ‚ÄúSnake‚Äù on it , I decided to make it exactly. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I study Rust: How I made the game "Snake"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/s3/lj/mu/s3ljmunwnal8rdbc4mbtrsqsia8.jpeg" alt="image"><br><br>  Recently I began to learn the programming language Rust and since when I study a new language I make <a href="https://ru.wikipedia.org/wiki/Snake_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">‚ÄúSnake‚Äù</a> on it <a href="https://ru.wikipedia.org/wiki/Snake_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">,</a> I decided to make it exactly. <br><br>  For 3D graphics, the <a href="https://github.com/three-rs/three">Three.rs</a> library was <a href="https://github.com/three-rs/three">used,</a> which is the port of the Three.js library. <br><br>  ‚Üí <a href="https://github.com/VictoremWinbringer/SnakeGameOnRust">Code</a> <br>  ‚Üí <a href="https://github.com/VictoremWinbringer/SnakeGameOnRust/releases">Download and play</a> <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Screenshot game</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/be/p3/vg/bep3vggv4uxjbhsnii0ykuhlda0.jpeg" alt="image"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Game code</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/*–ü–æ–¥–∫–ª—é—á–∞–µ–º –≤–Ω–µ—à–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –¢–∞–∫–∂–µ –∂–µ –≤ Cargo.toml [dependencies] rand="*" three="*" serde="*" bincode="*" serde_derive="*" –ø—Ä–æ–ø–∏—Å—ã–≤–∞–µ–º */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> rand; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> three; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> bincode; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-comment"><span class="hljs-comment">// –î–æ–±–∞–≤–ª—è–µ–º –Ω—É–∂–Ω—ã–µ –Ω–∞–º –≤–µ—â–∏ –≤ –Ω–∞—à—É –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏. use rand::Rng; use three::*; use std::error::Error; //Entities ------------------------------------------------------------------ /* –≠—Ç–æ –º–∞–∫—Ä–æ—Å—ã. –û–Ω–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç –∫–∞–∫–æ–π –Ω–∏ –±—É–¥—å –∫–æ–¥ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –í –Ω–∞—à–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å–ª—É—á–∞–µ: Debug - –°–æ–∑–¥–∞—Å—Ç –∫–æ–¥ –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª–∏—Ç—å –≤—ã–≤–æ–¥–∏—Ç—å –Ω–∞—à—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª Clone - –°–æ–∑–¥–∞—Å—Ç –∫–æ–¥ –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—à—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç. –µ. —É –Ω–∞—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ—è–≤–∏—Ç—å—Å—è –º–µ—Ç–æ–¥ clone() Eq –∏ PartialEq –ø–æ–∑–≤–æ–ª—è—Ç—å —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å –Ω–∞—à–∏ Point —Å –ø–æ–º–æ—â—å—é –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ == */ #[derive(Debug, Clone, Eq, PartialEq, Default)] //–û–±—å—è–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –¥–≤—É–º—è –ø–æ–ª—è–º–∏. –û–Ω–∞ –±—É–¥–µ—Ç –∏–≥—Ä–∞—Ç—å —Ä–æ–ª—å —Ç–æ—á–∫–∏ struct Point { x: u8, y: u8, } //–ú–µ—Ç–æ–¥—ã –Ω–∞—à–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã impl Point { // –ú–æ–∂–Ω–æ –±—ã–ª–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä == –í –æ–±—â–µ–º, —ç—Ç–æ –º–µ—Ç–æ–¥ –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è –ª–∏ –Ω–∞—à–∏ —Ç–æ—á–∫–∏ pub fn intersects(&amp;self, point: &amp;Point) -&gt; bool { self.x == point.x &amp;&amp; self.y == point.y } } #[derive(Debug, Clone, Eq, PartialEq, Default)] //–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –±—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –æ–±—ä–µ–∫—Ç–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü —Ñ—Ä–µ–π–º–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥–µ—Ç –¥–≤–∏–≥–∞—Ç—å—Å—è –Ω–∞—à–∞ –∑–º–µ–π–∫–∞ struct Frame { min_x: u8, min_y: u8, max_x: u8, max_y: u8, } impl Frame { pub fn intersects(&amp;self, point: &amp;Point) -&gt; bool { point.x == self.min_x || point.y == self.min_y || point.x == self.max_x || point.y == self.max_y } } #[derive(Debug, Clone, Eq, PartialEq)] //–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è —Å 4 –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ //–û–Ω–æ –±—É–¥–µ—Ç –æ—Ç–≤–µ—á–∞—Ç—å –∑–∞ —Ç–æ –∫—É–¥–∞ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –ø–æ–≤–µ—Ä–Ω—É—Ç–∞ –≥–æ–ª–æ–≤–∞ –∑–º–µ–π–∫–∏ enum Direction { Left, Right, Top, Bottom, } //–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç—Ä–µ–π—Ç–∞ (–≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö —ç—Ç–æ –µ—â–µ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å) // –¥–ª—è –Ω–∞—à–µ–≥–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è. //–û–±—å–µ–∫—Ç —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π —ç—Ç–æ—Ç —Ç—Ä–µ–π—Ç —Å–ø–æ—Å–æ–±–µ–Ω –∏–º–µ—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. impl Default for Direction { fn default() -&gt; Direction { return Direction::Right; } } #[derive(Debug, Clone, Eq, PartialEq, Default)] //–°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ –Ω–∞—à–∞ –∑–º–µ–π–∫–∞ struct Snake { direction: Direction, points: std::collections::VecDeque&lt;Point&gt;, start_x: u8, start_y: u8, } impl Snake { //–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ –Ω–∞—à–µ–π –∑–º–µ–π–∫–∏ pub fn new(x: u8, y: u8) -&gt; Snake { let mut points = std::collections::VecDeque::new(); for i in 0..3 { points.push_front(Point { x: x + i, y: i + y }); } Snake { direction: Direction::default(), points, start_x: x, start_y: y } } //–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –¥–ª–∏–Ω—É –Ω–∞—à–µ–π –∑–º–µ–π–∫–∏ –Ω–∞ –æ–¥–Ω—É —Ç–æ—á–∫—É pub fn grow(mut self) -&gt; Snake { if let Some(tail) = self.points.pop_back() { self.points.push_back(Point { x: tail.x, y: tail.y }); self.points.push_back(tail); } self } //–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –Ω–∞—à—É –∑–º–µ–π–∫—É –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ pub fn reset(self) -&gt; Snake { Snake::new(self.start_x, self.start_y) } //–ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç –≥–æ–ª–æ–≤—É –∑–º–µ–π–∫–∏ –≤ –Ω—É–∂–Ω–æ–º –Ω–∞–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ pub fn turn(mut self, direction: Direction) -&gt; Snake { self.direction = direction; self } //–ï—Å–ª–∏ –≥–æ–ª–æ–≤–∞ –∑–º–µ–π–∫–∏ –¥–æ—Å—Ç–∞–µ—Ç –¥–æ –µ–¥—ã —Ç–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –¥–ª–∏–Ω—É –∑–º–µ–π–∫–∏ –Ω–∞ –æ–¥–∏–Ω –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º –±—ã–ª–∞ –ª–∏ –µ–¥–∞ —Å—ä–µ–¥–µ–Ω–∞ pub fn try_eat(mut self, point: &amp;Point) -&gt; (Snake, bool) { let head = self.head(); if head.intersects(point) { return (self.grow(), true); } (self, false) } //–ï—Å–ª–∏ –≥–æ–ª–æ–≤–∞ –∑–º–µ–π–∫–∏ —Å—Ç–æ–ª–∫–Ω—É–ª–∞—Å—å —Å —Ñ—Ä–µ–π–º–æ–º —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–º–µ–π–∫—É –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ pub fn try_intersect_frame(mut self, frame: &amp;Frame) -&gt; Snake { let head = self.head(); if frame.intersects(&amp;head) { return self.reset(); } self } //–ï—Å–ª–∏ –≥–æ–ª–æ–≤–∞ –∑–º–µ–π–∫–∏ —Å—Ç–æ–ª–∫–Ω—É–ª–∞—Å—å —Å –æ—Å—Ç–∞–ª—å–Ω–æ–π —á–∞—Å—Ç—å—é —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–º–µ–π–∫—É –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ. pub fn try_intersect_tail(mut self) -&gt; Snake { let head = self.head(); let p = self.points.clone(); let points = p.into_iter().filter(|p| head.intersects(p)); if points.count() &gt; 1 { return self.reset(); } self } //–î–∞–µ—Ç –≥–æ–ª–æ–≤—É –∑–º–µ–π–∫–∏ pub fn head(&amp;self) -&gt; Point { self.points.front().unwrap().clone() } //–ü–µ—Ä–µ–º–µ—â–∞–µ—Ç –∑–º–µ–π–∫—É –Ω–∞ –æ–¥–Ω—É —Ç–æ—á–∫—É –≤ —Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—É–¥–∞ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Å–º–æ—Ç—Ä–∏—Ç –≥–æ–ª–æ–≤–∞ –∑–º–µ–π–∫–∏ pub fn move_snake(mut self) -&gt; Snake { if let Some(mut tail) = self.points.pop_back() { let head = self.head(); match self.direction { Direction::Right =&gt; { tail.x = head.x + 1; tail.y = head.y; } Direction::Left =&gt; { tail.x = head.x - 1; tail.y = head.y; } Direction::Top =&gt; { tail.x = head.x; tail.y = head.y - 1; } Direction::Bottom =&gt; { tail.x = head.x; tail.y = head.y + 1; } } self.points.push_front(tail); } self } } //Data Access Layer ---------------------------------------------------------------- #[derive(Debug, Clone, Eq, PartialEq, Default)] //–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –µ–¥—ã –¥–ª—è –∑–º–µ–π–∫–∏ struct FoodGenerator { frame: Frame } impl FoodGenerator { //–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é —Ç–æ—á–∫—É –≤ —Å–ª—É—á–∞–π–Ω–æ–º –º–µ—Å—Ç–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö —Ñ—Ä–µ–π–º–∞ pub fn generate(&amp;self) -&gt; Point { let x = rand::thread_rng().gen_range(self.frame.min_x + 1, self.frame.max_x); let y = rand::thread_rng().gen_range(self.frame.min_y + 1, self.frame.max_y); Point { x, y } } } #[derive(Serialize, Deserialize)] //–•—Ä–∞–Ω–∏—Ç —Ç–µ–∫—É—â–∏–π –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å—á–µ—Ç –∏–≥—Ä—ã struct ScoreRepository { score: usize } impl ScoreRepository { //–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ —Å—á–µ—Ç–∞ –≤ —Ñ–∞–π–ª–µ // Result —ç—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –≤ —Å–µ–±–µ –ª–∏–±–æ –æ—à–∏–±–∫—É –ª–∏–±–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏–π fn save(value: usize) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; { use std::fs::File; use std::io::Write; let score = ScoreRepository { score: value }; //–°–µ—Ä–∏–∞–ª–∏–∑—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ –º–∞—Å—Å–∏–≤ –±–∞–π—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ bincode // –û–ø–µ—Ä–∞—Ç–æ—Ä ? –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É –Ω–∞ –≤–µ—Ä—Ö —Ç. –µ. –µ—Å–ª–∏ —Ç—É—Ç –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞ —Ç–æ –æ–Ω–∞ —Å—Ç–∞–Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –º–µ—Ç–æ–¥–∞ let bytes: Vec&lt;u8&gt; = bincode::serialize(&amp;score)?; //–°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ñ–∞–π–ª –∏–ª–∏ –µ—Å–ª–∏ –æ–Ω —É–∂–µ —Å—É—à–µ—Å—Ç–≤—É–µ—Ç —Ç–æ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –µ–≥–æ. let mut file = File::create(".\\score.data")?; match file.write_all(&amp;bytes) { Ok(t) =&gt; Ok(t), //Error —ç—Ç–æ —Ç—Ä–µ–π—Ç –∞ —É —Ç—Ä–µ–π—Ç –Ω–µ—Ç —Ç–æ—á–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø–æ—ç—Ç–æ–º—É // –Ω–∞–º –Ω–∞–¥–æ –æ–±–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ Box –∏ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –º—ã —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —É–∫–∞–∑–∞—Ç–µ–ª–µ–º –Ω–∞ //–∫—É—á—É –≤ –ø–∞–º—è—Ç–∏ –≥–¥–µ –ª–µ–∂–∏—Ç –Ω–∞—à –æ–±—ä–µ–∫—Ç –∞ –Ω–µ —Å —Å–∞–º–∏–º –æ–±—ä–µ–∫—Ç–æ–º –∞ —É —É–∫–∞–∑–∞—Ç–µ–ª—è –µ—Å—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä // –∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ Err(e) =&gt; Err(Box::new(e)) } } //–ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏–∑ —Ñ–∞–π–ª–∞ fn load() -&gt; Result&lt;usize, Box&lt;Error&gt;&gt; { use std::fs::File; let mut file = File::open("./score.data")?; let data: ScoreRepository = bincode::deserialize_from(file)?; Ok(data.score) } } //Business Logic Layer------------------------------------------------------------ #[derive(Debug, Clone, Default)] //–û–±—ä–µ–∫—Ç–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ª–æ–≥–∏–∫–∏ –Ω–∞—à–µ–π –∏–≥—Ä—ã struct Game { snake: Snake, frame: Frame, food: Point, food_generator: FoodGenerator, score: usize, max_score: usize, total_time: f32, } impl Game { //–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–≥—Ä—ã —Å —Ñ—Ä–µ–π–º–æ–º –∑–∞–¥–∞–Ω–Ω–æ–π –≤—ã—Å–æ—Ç—ã –∏ —à–∏—Ä–∏–Ω—ã fn new(height: u8, width: u8) -&gt; Game { let frame = Frame { min_x: 0, min_y: 0, max_x: width, max_y: height }; let generator = FoodGenerator { frame: frame.clone() }; let food = generator.generate(); let snake = Snake::new(width / 2, height / 2); Game { snake, frame, food, food_generator: generator, score: 0, max_score: match ScoreRepository::load() { Ok(v) =&gt; v, Err(_) =&gt; 0 }, total_time: 0f32, } } // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–æ—à–ª–æ –ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ —Å –º–æ–º–µ–Ω—Ç–∞ –∫–æ–≥–¥–∞ –º—ã –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑ //–¥–≤–∏–≥–∞–ª–∏ –Ω–∞—à—É –∑–º–µ–π–∫—É –∏ –µ—Å–ª–∏ –¥–∞ —Ç–æ –ø–µ—Ä–µ–¥–≤–∏–≥–∞–µ–º –µ–µ // –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ –≥–æ–ª–æ–≤—ã –∑–º–µ–π–∫–∏ —Å –æ—Å—Ç–∞–ª—å–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏ –∏–≥—Ä—ã // –∏–Ω–∞—á–µ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º fn update(mut self, time_delta_in_seconds: f32) -&gt; Game { let (game, is_moving) = self.is_time_to_move(time_delta_in_seconds); self = game; if is_moving { self.snake = self.snake.clone() .move_snake() .try_intersect_tail() .try_intersect_frame(&amp;self.frame); self.try_eat() } else { self } } //–ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Å—Ç–∞–ª–æ –ª–∏ –≤—Ä–µ–º—è –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å –∑–º–µ–π–∫—É. fn is_time_to_move(mut self, time_delta_in_seconds: f32) -&gt; (Game, bool) { let time_to_move: f32 = 0.030; self.total_time += time_delta_in_seconds; if self.total_time &gt; time_to_move { self.total_time -= time_to_move; (self, true) } else { (self, false) } } //–ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—ä–µ–ª–∞ –ª–∏ –Ω–∞—à–∞ –∑–º–µ–π–∫—É –µ–¥—É –∏ –µ—Å–ª–∏ –¥–∞ // —Ç–æ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –µ–¥—É, –Ω–∞—á–∏—Å–ª—è–µ–º –∏–≥—Ä–æ–∫—É –æ—á–∫–∏ // –∏–Ω–∞—á–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–≥—Ä–æ–∫—É —Ç–µ–∫—É—â–∏–π —Å—á–µ—Ç fn try_eat(mut self) -&gt; Game { let initial_snake_len = 3; if self.snake.points.len() == initial_snake_len { self.score = 0 } let (snake, eaten) = self.snake.clone().try_eat(&amp;self.food); self.snake = snake; if eaten { self.food = self.food_generator.generate(); self.score += 1; if self.max_score &lt; self.score { self.max_score = self.score; ScoreRepository::save(self.max_score); } }; self } // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∑–º–µ–π–∫—É –≤ –Ω—É–∂–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ fn handle_input(mut self, input: Direction) -&gt; Game { let snake = self.snake.turn(input); self.snake = snake; self } } //Application Layer-------------------------------------------------------------- // --- Model ---- #[derive(Debug, Clone, Eq, PartialEq)] enum PointDtoType { Head, Tail, Food, Frame, } impl Default for PointDtoType { fn default() -&gt; PointDtoType { PointDtoType::Frame } } #[derive(Debug, Clone, Eq, PartialEq, Default)] //–ú–æ–¥–µ–ª—å –∫–æ—Ç–æ—Ä—É –±—É–¥–µ—Ç –≤–∏–¥–µ—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é. struct PointDto { x: u8, y: u8, state_type: PointDtoType, } //------------------------------Controller ----------------------------- #[derive(Debug, Clone, Default)] // –ö–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø–æ—Å—Ä–µ–¥–Ω–∏–∫–æ–º –º–µ–∂–¥—É –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º –∏ –ª–æ–≥–∏–∫–æ–π –Ω–∞—à–µ–π –∏–≥—Ä—ã struct GameController { game: Game, } impl GameController { fn new() -&gt; GameController { GameController { game: Game::new(30, 30) } } //–ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–ª–µ–∫—Ü–∏—é —Ç–æ—á–µ–∫ –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –æ—Ç —Ä–∏—Å–æ–≤–∞—Ç—å –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç fn get_state(&amp;self) -&gt; Vec&lt;PointDto&gt; { let mut vec: Vec&lt;PointDto&gt; = Vec::new(); vec.push(PointDto { x: self.game.food.x, y: self.game.food.y, state_type: PointDtoType::Food }); let head = self.game.snake.head(); vec.push(PointDto { x: head.x, y: head.y, state_type: PointDtoType::Head }); //–í—Å–µ —Ç–æ—á–∫–∏ –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º –≥–æ–ª–æ–≤—ã –∑–º–µ–∏ for p in self.game.snake.points.iter().filter(|p| **p != head) { vec.push(PointDto { x: px, y: py, state_type: PointDtoType::Tail }); } //–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ —Ñ—Ä–µ–π–º–∞ for x in self.game.frame.min_x..=self.game.frame.max_x { vec.push(PointDto { x: x, y: self.game.frame.max_y, state_type: PointDtoType::Frame }); vec.push(PointDto { x: x, y: self.game.frame.min_y, state_type: PointDtoType::Frame }); } //–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ —Ñ—Ä–µ–π–º–∞ for y in self.game.frame.min_y..=self.game.frame.max_y { vec.push(PointDto { x: self.game.frame.max_x, y: y, state_type: PointDtoType::Frame }); vec.push(PointDto { x: self.game.frame.min_x, y: y, state_type: PointDtoType::Frame }); } vec } //–û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã fn update(mut self, time_delta: f32, direction: Option&lt;Direction&gt;) -&gt; GameController { let game = self.game.clone(); self.game = match direction { None =&gt; game, Some(d) =&gt; game.handle_input(d) } .update(time_delta); self } pub fn get_max_score(&amp;self) -&gt; usize { self.game.max_score.clone() } pub fn get_score(&amp;self) -&gt; usize { self.game.score.clone() } } //------------------------View --------------- //–ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–≥—Ä—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç –Ω–µ–≥–æ –∫–æ–º–∞–Ω–¥ struct GameView { controller: GameController, window: three::Window, camera: three::camera::Camera, ambient: three::light::Ambient, directional: three::light::Directional, font: Font, current_score: Text, max_score: Text, } impl GameView { fn new() -&gt; GameView { let controller = GameController::new(); //–°–æ–∑–¥–∞–µ–º –æ–∫–Ω–æ –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –Ω–∞—à–∞ –∏–≥—Ä–∞ let mut window = three::Window::new("3D Snake Game By Victorem"); //–°–æ–∑–¥–∞–µ–º –∫–∞–º–µ—Ä—É —á–µ—Ä–µ–∑ –∫–æ—Ç–æ—Ä—É—é –∏–≥—Ä–æ–∫ –±—É–¥–µ—Ç –≤–∏–¥–µ—Ç—å –Ω–∞—à—É –∏–≥—Ä—É let camera = window.factory.perspective_camera(60.0, 10.0..40.0); //–ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–∞–º–µ—Ä—É –≤ [x, y, z] camera.set_position([15.0, 15.0, 30.0]); //–°–æ–∑–¥–∞–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –æ–∫—Ä—É–∂–∞—é—â–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ let ambient_light = window.factory.ambient_light(0xFFFFFF, 0.5); window.scene.add(&amp;ambient_light); //–°–æ–∑–¥–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π —Å–≤–µ—Ç let mut dir_light = window.factory.directional_light(0xffffff, 0.5); dir_light.look_at([350.0, 350.0, 550.0], [0.0, 0.0, 0.0], None); window.scene.add(&amp;dir_light); //–ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ —Ñ–∞–π–ª–∞ —à—Ä–∏—Ñ—Ç –∫–æ—Ç–æ—Ä—ã–º –±—É–¥–µ—Ç –ø–∏—Å–∞—Ç—å —Ç–µ–∫—Å—Ç let font = window.factory.load_font(".\\DejaVuSans.ttf"); //–°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —ç–∫—Ä–∞–Ω–µ –∫—É–¥–∞ –±—É–¥–µ—Ç –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Å—á–µ—Ç let current_score = window.factory.ui_text(&amp;font, "0"); let mut max_score = window.factory.ui_text(&amp;font, "0"); max_score.set_pos([0.0, 40.0]); window.scene.add(&amp;current_score); window.scene.add(&amp;max_score); GameView { controller, window, camera, ambient: ambient_light, directional: dir_light, font, current_score, max_score } } //–°—á–∏—Ç—ã–≤–∞–µ–º –∫–ª–∞–≤–∏—à—É –∫–æ—Ç–æ—Ä—É—é –ø–æ—Å–ª–µ–¥–Ω–µ–π –Ω–∞–∂–∞–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –µ–µ –≤—ã–±–∏—Ä–∞–µ–º –Ω–æ–≤–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ fn get_input(&amp;self) -&gt; Option&lt;Direction&gt; { match self.window.input.keys_hit().last() { None =&gt; None, Some(k) =&gt; match *k { three::Key::Left =&gt; Some(Direction::Left), three::Key::Right =&gt; Some(Direction::Right), three::Key::Down =&gt; Some(Direction::Top), three::Key::Up =&gt; Some(Direction::Bottom), _ =&gt; None, } } } //–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –º–æ–¥–µ–ª—å –ø–æ–ª—É—á–µ–Ω–Ω—É—é –æ—Ç –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞ –≤ –Ω–∞–±–æ—Ä —Å–µ—Ç–æ—á–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞—à–µ–π —Å—Ü–µ–Ω—ã fn get_meshes(mut self) -&gt; (Vec&lt;Mesh&gt;, GameView) { //–°–æ–∑–¥–∞–µ–º —Å—Ñ–µ—Ä—É let sphere = &amp;three::Geometry::uv_sphere(0.5, 24, 24); //–°–æ–∑–¥–∞–µ–º –∑–µ–ª–µ–Ω–æ–µ –ø–æ–∫—Ä—ã—Ç–∏–µ –¥–ª—è –Ω–∞—à–µ–π —Å—Ñ–µ—Ä—ã —Å –º–æ–¥–µ–ª—å—é –æ—Å–≤–µ—â–µ–Ω–∏—è –ø–æ –§–æ–Ω–≥—É let green = &amp;three::material::Phong { color: three::color::GREEN, glossiness: 30.0, }; let blue = &amp;three::material::Phong { color: three::color::BLUE, glossiness: 30.0, }; let red = &amp;three::material::Phong { color: three::color::RED, glossiness: 30.0, }; let yellow = &amp;three::material::Phong { color: three::color::RED | three::color::GREEN, glossiness: 30.0, }; // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –Ω–∞—à—É –º–æ–¥–µ–ª—å –≤ —Å–µ—Ç–æ—á–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã let meshes = self.controller.clone().get_state().iter().map(|s| { let state = s.clone(); match state.state_type { PointDtoType::Frame =&gt; { let m = self.window.factory.mesh(sphere.clone(), blue.clone()); m.set_position([state.x as f32, state.y as f32, 0.0]); m } PointDtoType::Tail =&gt; { let m = self.window.factory.mesh(sphere.clone(), yellow.clone()); m.set_position([state.x as f32, state.y as f32, 0.0]); m } PointDtoType::Head =&gt; { let m = self.window.factory.mesh(sphere.clone(), red.clone()); m.set_position([state.x as f32, state.y as f32, 0.0]); m } PointDtoType::Food =&gt; { let m = self.window.factory.mesh(sphere.clone(), green.clone()); m.set_position([state.x as f32, state.y as f32, 0.0]); m } } }).collect(); (meshes, self) } //–û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—à–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ fn update(mut self) -&gt; GameView { //–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ä–µ–º–µ–Ω–∏ –ø—Ä–æ—à–µ–¥—à–µ–µ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–≥—Ä—ã let elapsed_time = self.window.input.delta_time(); let input = self.get_input(); let controller = self.controller.update(elapsed_time, input); self.controller = controller; self } //–û—Ç–æ–±—Ä–∞–∂–∞–µ–º –Ω–∞—à–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫—É fn draw(mut self) -&gt; GameView { let (meshes, view) = self.get_meshes(); self = view; //–î–æ–±–∞–≤–ª—è–µ–º –º–µ—à–∏ –Ω–∞ —Å—Ü–µ–Ω—É. for m in &amp;meshes { self.window.scene.add(m); } //–û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Å—Ü–µ–Ω—É –Ω–∞ –∫–∞–º–µ—Ä—É self.window.render(&amp;self.camera); //–û—á–∏—â–∞–µ–º —Å—Ü–µ–Ω—É for m in meshes { self.window.scene.remove(m); } //–û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ç–µ–∫—É—â–∏–π —Å—á–µ—Ç self.max_score.set_text(format!("MAX SCORE: {}", self.controller.get_max_score())); self.current_score.set_text(format!("CURRENT SCORE: {}", self.controller.get_score())); self } // –ó–∞–ø—É—Å–∫–∞–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –æ—Ç —Ä–∏—Å–æ–≤–∫–∏ –∏–≥—Ä—ã pub fn run(mut self) { //–ü—Ä–µ—Ä—ã–≤–∞–µ—à—å —Ü–∏–∫–ª –µ—Å—Ç—å –æ–∫–Ω–æ –∏–≥—Ä—ã –∑–∞–∫—Ä—ã–ª–æ—Å—å –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–∞–ª –∫–ª–∞–≤–∏—à—É —ç—Å–∫–µ–π–ø while self.window.update() &amp;&amp; !self.window.input.hit(three::KEY_ESCAPE) { self = self.update().draw(); } } } fn main() { let mut view = GameView::new(); view.run(); }</span></span></code> </pre> <br></div></div><br>  In addition to Three.rs, I also considered <a href="https://github.com/PistonDevelopers/piston">Piston</a> - a set of libraries for creating games and <a href="https://github.com/amethyst/amethyst">Ametist</a> - a game engine.  I chose Three.rs because it seemed to me the simplest and most suitable for prototyping. <br>  Unfortunately, within the framework of this game, it was not possible to touch the streams and work with the network.  I will try it on the next project.  So far I like the language and working with him is a pleasure.  I would be grateful for practical advice and constructive criticism. </div><p>Source: <a href="https://habr.com/ru/post/428830/">https://habr.com/ru/post/428830/</a></p>
<section class="all-articles-navigation-panel js-all-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>