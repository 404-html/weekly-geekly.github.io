<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I created my online game. Part 1: Networking</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all! I recently had a vacation, and I had time to quietly program my home projects. I wanted to make my own simple online game on Rust. More ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I created my online game. Part 1: Networking</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xt/sd/nh/xtsdnhuveu_gvoczdjrneieyzlg.jpeg"><br><br>  Hello to all!  I recently had a vacation, and I had time to quietly program my home projects.  I wanted to make my own simple online game on Rust.  More precisely, a simple 2D shooter.  I decided to first make the network part, and there it will already be clear that yes how.  Since the genre involves action in all fields, so I decided to use the UDP protocol.  Began to design the architecture of the network part.  I realized that you can take it all to a separate library.  I also downloaded the resulting library on crates.io, under the MIT license, because: a) It will be more convenient for me to connect it from there to my projects from there.  b) Maybe she is still useful to someone and will be useful.  For details, welcome under cat. <a name="habracut"></a><br><br><h2>  Links </h2><br>  -&gt; <a href="https://github.com/VictoremWinbringer/Victorem">Sources</a> <br>  -&gt; <a href="https://crates.io/crates/victorem">Library on crates.io</a> <br>  -&gt; <a href="https://docs.rs/victorem/">Documentation</a> <br><br><h2>  Usage example </h2><br><h3>  Customer </h3><br><pre><code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//–ü–æ–¥–∫–ª—é—á–∞–µ–º –Ω–∞—à—É –±–∏–±–ª–∏–æ—Ç–µ–∫—É use victorem; fn main() -&gt; Result&lt;(), victorem::Exception&gt; { //–°–æ–∑–¥–∞–µ–º —Å–æ–∫–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–ª—É—à–∞–µ—Ç –ø–æ—Ä—Ç 11111 –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –Ω–∞ –∞–¥—Ä–µ—Å 127.0.0.1:22222 let mut socket = victorem::ClientSocket::new("11111", "127.0.0.1:22222")?; loop { //–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–π—Ç—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä socket.send(b"Client!".to_vec()); //–ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–æ—á–∏—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞. –í —Å–ª—É—á–∞–µ–º —É—Å–ø–µ—Ö–∞ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –±–∞–π—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –∏ –≤—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∫–æ–Ω—Å–æ–ª—å socket.recv().map(|v| String::from_utf8(v).map(|s| println!("{}",s))); } }</span></span></code> </pre> <br><h3>  Server </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//–ü–æ–¥–∫–ª—é—á–∞–µ–º –Ω–∞—à—É –±–∏–±–ª–∏–æ—Ç–µ–∫—É use victorem; use std::time::Duration; use std::net::SocketAddr; //–°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –Ω–∞—à–∞ –∏–≥—Ä–∞. –í –Ω–µ–π –±—É–¥—É—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞—à–µ–π –∏–≥—Ä—ã –∏ –≤—Å—è –µ–µ –ª–æ–≥–∏–∫–∞. struct ClientServerGame; //–†–µ–∞–ª–∏–∑—É–µ–º –¥–ª—è –Ω–∞—à–µ–π –∏–≥—Ä—ã –ø—Ä–æ—Ç–æ–∫–æ–ª Game, —á—Ç–æ–±—ã –µ–µ –º–æ–∂–Ω–æ –±—ã–ª–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–∞ –Ω–∞—à–µ–º —Å–µ—Ä–≤–µ—Ä–µ impl victorem::Game for ClientServerGame { //–í—ã–∑—ã–≤–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –ø—Ä–∏—Ö–æ–¥–∏—Ç –∫–æ–º–∞–Ω–¥–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –±—É–ª–µ–≤–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –µ—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç false, —Ç–æ —Å–µ—Ä–≤–µ—Ä –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è. fn handle_command(&amp;mut self, delta_time: Duration, commands: Vec&lt;Vec&lt;u8&gt;&gt;, from: SocketAddr) -&gt; bool { for command in commands { String::from_utf8(command).map(|s| println!("{}",s)); } true } //–í—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å–µ—Ä–≤–µ—Ä–æ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑ –≤ 30 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥. –ï—Å–ª–∏ –≤–µ—Ä–Ω—É—Ç—å –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤ –±–∞–π—Ç, —Ç–æ –æ–Ω –Ω–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. –ï—Å–ª–∏ –∂–µ –≤ –≤–µ–∫—Ç–æ—Ä–µ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ, —Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏—Ö –Ω–∞ —Å–µ—Ä–≤–µ—Ä. fn draw(&amp;mut self, delta_time: Duration) -&gt; Vec&lt;u8&gt; { b"Server!".to_vec() } } fn main() -&gt; Result&lt;(), victorem::Exception&gt; { //–°–æ–∑–¥–∞–µ–º —Å–µ—Ä–≤–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞—à–µ–π ClientServerGame –∏ –±—É–¥–µ—Ç —Å–ª—É—à–∞—Ç—å –ø–æ—Ä—Ç 22222 let mut server = victorem::GameServer::new(ClientServerGame, "22222")?; //–ó–∞–ø—É—Å–∫–∞–µ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –∏–≥—Ä—ã –∏ –±–ª–æ–∫–∏—Ä—É–µ—Ç —Ç–µ–∫—É—â–∏–π –ø–æ—Ç–æ–∫. server.run(); Ok(()) }</span></span></code> </pre><br><h2>  Internal device </h2><br>  In general, if I used <a href="https://crates.io/crates/laminar">Laminar</a> for the network part and not raw UDP sockets, the code could be reduced by a factor of 100, and I use the algorithm described in this series of articles - <a href="https://habr.com/post/276067/">Network programming for game developers</a> . <br>  The server architecture involves receiving commands from clients (for example, pressing a mouse button or some button on the keyboard) and sending them a status (for example, the current position of the units and the direction they are looking) with which the client can display a picture to the player. <br><br><h3>  On server </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–π–¥–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞ –∏ –∫–æ–¥–∏—Ä—É–µ—Ç –≤ –±–∏—Ç–∞—Ö u32 —á–∏—Å–ª–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–∞–∫–µ—Ç–æ–≤ –¥–æ –Ω–µ–≥–æ, –≥–¥–µ 0 - –ø–∞–∫–µ—Ç –ø–æ–ª—É—á–µ–Ω, 1 - –ø–∞–∫–µ—Ç –Ω–µ –ø–æ–ª—É—á–µ–Ω, –∏ –∫–ª–∏–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–≥–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ. pub fn get_lost(&amp;self) -&gt; (u32, u32) { let mut sequence: u32 = 0; let mut x = 0; let mut y = self.last_received_packet_id; while x &lt; 32 &amp;&amp; y &gt; 1 { y -= 1; if !self.received.contains(&amp;y) { let mask = 1u32 &lt;&lt; x; sequence |= mask; } x += 1; } (sequence, self.last_received_packet_id) }</span></span></code> </pre> <br><h3>  On the client </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//–î–µ–∫–æ–¥–∏—Ä—É–µ—Ç –∏–∑ –∞–π–¥–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –ø–∞–∫–µ—Ç–∞ (max_id) –∏ –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤ –±–∏—Ç–∞—Ö –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–∞–∫–µ—Ç–æ–≤ –ø–æ—Å–ª–µ –Ω–µ–≥–æ (sequence) –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç—ã. –ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏—Ö –∏–∑ –∫–µ—à–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å–≤–æ–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ fn get_lost(&amp;mut self, max_id: u32, sequence: u32) -&gt; Vec&lt;CommandPacket&gt; { let mut x = max_id; let mut y = 0; let mut ids = Vec::&lt;u32&gt;::new(); //–ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–æ–ª—É—á–∏–ª –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∏, —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π –≤ –∫–µ—à –ø–∞–∫–µ—Ç, —Ç–æ –µ–≥–æ —Ç–æ–∂–µ –Ω—É–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å. let max_cached = self.cache.get_max_id(); if max_cached != max_id { ids.push(max_cached); } while x &gt; 0 &amp;&amp; y &lt; 32 { x -= 1; let mask = 1u32 &lt;&lt; y; y += 1; let res = sequence &amp; mask; if res &gt; 0 { ids.push(x); } } self.cache.get_range(&amp;ids) }</span></span></code> </pre> <br><h2>  Epilogue </h2><br>  In fact, it was possible to make the command delivery algorithm easier.  On the server, accept only the packet that has the id more than the last packet received by +1, and discards the rest.  Send the client the last package received.  On the client, keep the cache of all the commands that the user tried to send to the server.  Every time when a new state comes from the server with the last package received by the server, delete it from the cache and all the packages with the ID less than it has.  All remaining packages are sent to the server again. <br>  Further, when I will make the game itself, in the process of use I will further improve and optimize lib.  Perhaps I will find some more bugs. <br><br>  I found here the project of the game server on C # - <a href="https://github.com/MarkioE/Networker">Networker</a> + on Rust there is a <a href="https://github.com/rust-game/leaf">leaf</a> like, like an analog game server on Go - leaf.  Only there development in the process. <br><br>  PS Dear friend, if you are a beginner and decided to read my code to this project and you will see there tests that I wrote.  So here's my advice to you - do not do it as I do.  I there all in a heap in the tests mixed and did not follow the template "AAA" (google what it is).  So do not need to be in production.  A normal test should check one thing and not several conditions at once and should consist of the following steps: <br><br><ol><li>  You set your variables; </li><li>  You perform the action you want to test; </li><li>  You compare the result with the expected. </li></ol><br>  For example, <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span></span>(x:<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { x+<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one_fn_should_add_one_to_it_argument</span></span></span></span>(){ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = x+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">///////////////////////// let result = add_one(x); ////////////////////////////////// assert_eq!(expected,result); }</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/435384/">https://habr.com/ru/post/435384/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>