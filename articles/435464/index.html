<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing Node.js projects. Part 2. Evaluation of the effectiveness of tests, continuous integration and analysis of code quality</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üí Testing Node.js projects. Part 1. Anatomy of tests and types of tests 

 Today, in the second part of the translation of material devoted to testing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Testing Node.js projects. Part 2. Evaluation of the effectiveness of tests, continuous integration and analysis of code quality</h1><div class="post__text post__text-html js-mediator-article">  ‚Üí <a href="https://habr.com/company/ruvds/blog/435462/">Testing Node.js projects.</a>  <a href="https://habr.com/company/ruvds/blog/435462/">Part 1. Anatomy of tests and types of tests</a> <br><br>  Today, in the second part of the translation of material devoted to testing Node.js projects, we will talk about evaluating the effectiveness of tests and about code quality analysis. <br><br> <a href="https://habr.com/company/ruvds/blog/435464/"><img src="https://habrastorage.org/getpro/habr/post_images/f16/1a0/3e2/f161a03e2b08ae35b31f718a083a39a0.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Section 3. Evaluation of the effectiveness of tests</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç19.</font>  <font color="#3AC1EF">Achieve a sufficiently high level of code coverage tests in order to gain confidence in its proper operation.</font>  <font color="#3AC1EF">Usually good results are given by approximately 80% coverage.</font> </h3><br><h4>  Recommendations </h4><br>  The purpose of testing is to make sure that the programmer has already done so that the programmer can continue productive work on the project.  Obviously, the larger the volume of the verified code, the stronger the confidence that everything works as it should.  The test code coverage indicator indicates how many lines (branches, commands) have been tested.  What should this indicator be?  It is clear that 10-30% is too little to give confidence that the project will work without errors.  On the other hand, the desire for 100% coverage of the code with tests may be too expensive and can distract the developer from the most important fragments of the program, causing him to look in the code for places to which existing tests do not reach.  If you give a more complete answer to the question of what should be the coverage of the code with tests, then we can say that the indicator you should strive for depends on the application being developed.  For example, if you are busy writing software for the next generation Airbus A380 aircraft, then 100% is an indicator that is not even discussed.  But if you create a website where caricature galleries will be displayed, then probably 50% is already a lot.  Although testing experts say that the level of code coverage with tests that you should strive for depends on the project, many of them mention the figure of 80%, which is probably suitable for most applications.  For example, <a href="https://martinfowler.com/bliki/TestCoverage.html">here</a> we are talking about something in the region of 80-90%, and, according to the author of this material, 100% coverage of the code with tests causes him suspicion, since it may indicate that the programmer writes tests only in order to get The report is a beautiful number. <br><br>  In order to use the indicators of code coverage tests, you will need to properly configure your continuous integration system (CI, Continuous Integration).  This will allow, if the corresponding indicator does not reach a certain threshold, to stop the assembly of the project.  <a href="https://jestjs.io/docs/ru/configuration">Here is</a> information about setting up a Jest to collect information about test coverage.  In addition, it is possible to configure coverage thresholds not for the entire code, but by focusing on individual components.  In addition to this, consider the possibility of detecting a decrease in code coverage by tests.  This happens, for example, when a new code is added to a project.  Monitoring this indicator will encourage developers to increase the amount of tested code, or at least to keep this volume at the existing level.  Considering the above, code coverage with tests is just one indicator, quantified, which is not enough to fully evaluate the reliability of tests.  In addition, as will be shown below, its high levels still do not indicate that the ‚Äútest-covered‚Äù code is actually verified. <br><br><h4>  Implications of derogation </h4><br>  The programmer's confidence in the high quality of the code and the corresponding indicators related to testing go hand in hand.  The programmer can not be afraid of errors in the event that he does not know that most of the code of his project is covered with tests.  These concerns can slow down the work on the project. <br><br><h4>  Example </h4><br>  Here‚Äôs what a typical test coverage report looks like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/96b/951/4fc/96b9514fc0e5d96553a4fc8551793d27.png"></div><br>  <i><font color="#999999">Report on code coverage tests, formed by means of Istanbul</font></i> <br><br><h4>  The right approach </h4><br>  Here is an example of setting the desired level of coverage with the component code tests and the overall level of this indicator in Jest. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e23/feb/473/e23feb47399296324bb96b2109d4b360.jpg"></div><br>  <i><font color="#999999">Setting the desired level of code coverage tests for the entire project and for a specific component</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç20.</font>  <font color="#3AC1EF">Examine the test code coverage reports for untested code points and other anomalies.</font> </h3><br><h4>  Recommendations </h4><br>  Some problems tend to skip through a variety of error detection systems.  Such things can be difficult to detect using traditional tools.  Perhaps this does not apply to these errors.  Rather, we are talking about the unexpected behavior of the application, which can have devastating consequences.  For example, it often happens that some code fragments are either never used or are extremely rarely called.  For example, you think that the <code>PricingCalculator</code> class mechanisms are always used to set the price of a product, but in fact it turns out that this class is not used at all, and there are 10,000 products in the database, and the online store that uses the system has a lot of sales ... Reports on code coverage with tests help the developer understand if an application works the way it thinks it should work.  In addition, from the reports you can find out which project code is not being tested.  If you focus on the general indicator, which indicates that tests cover 80% of the code, you cannot find out whether critical parts of the application are being tested.  In order to generate such a report, it is sufficient to properly configure the tool you use to run the tests.  Such reports usually look quite nice, and their analysis, which does not take much time, allows you to detect any surprises. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  If you don‚Äôt know which parts of your code remain untested, then you don‚Äôt know where to expect problems. <br><br><h4>  Wrong approach </h4><br>  Look at the following report and think about what looks unusual in it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ce/883/889/1ce88388923499c997c6fdc4606d3c10.png"></div><br>  <i><font color="#999999">Report indicating unusual system behavior</font></i> <br><br>  The report is based on the real usage scenarios of the application and allows you to see the unusual behavior of the program associated with the user logon.  Namely, an unexpectedly large number of unsuccessful attempts to enter the system in comparison with successful ones is evident.  After analyzing the project, it turned out that the reason for this was an error in the frontend, due to which the interface part of the project constantly sent corresponding requests to the server API for logging into the system. <br><br><h3>  <font color="#3AC1EF">‚ñç21.</font>  <font color="#3AC1EF">Measure logical code coverage with tests using mutation testing</font> </h3><br><h4>  Recommendations </h4><br>  Traditional indicators of code coverage tests may be unreliable.  So, in the report there may be a figure of 100%, but at the same time absolutely all the functions of the project will return incorrect values.  How to explain this?  The point is that the test code coverage indicator only indicates which lines of code were executed under the control of the testing system, but it does not depend on whether something was really tested, that is, on whether the test was approved aimed at verifying the correctness of the results of the code.  This is reminiscent of a man who, returning from a trip abroad, demonstrates stamps in his passport.  The stamps prove that he has been somewhere, but they don‚Äôt say anything about whether he did what he went on a business trip for. <br><br>  Here mutation tests can help us, which allow us to find out how much code has been actually tested, and not just visited by the testing system.  For mutation testing, you can use the <a href="https://stryker-mutator.io/">Stryker</a> JS library.  Here are the principles for how it works: <br><br><ol><li>  It intentionally changes the code, creating errors in it.  For example, the code <code>newOrder.price===0</code> turns into <code>newOrder.price!=0</code> .  These ‚Äúbugs‚Äù are called mutations. </li><li>  She runs tests.  If they are passed, then we have problems, because tests do not perform their task of detecting errors, and the "mutants" are said to "survive."  If the tests indicate errors in the code, then everything is in order - the ‚Äúmutants‚Äù ‚Äúdie‚Äù. </li></ol><br>  If it turns out that all the ‚Äúmutants‚Äù were ‚Äúkilled‚Äù (or, at least, most of them did not survive), this gives a higher level of confidence in the high quality of the code and the tests that test it than the traditional metrics of code coverage of the tests.  At the same time, the time required for setting up and conducting mutational testing is comparable to that needed when using conventional tests. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  If the traditional indicator of code coverage by tests indicates that tests cover 85% of the code, this does not mean that the tests are able to detect errors in this code. <br><br><h4>  Wrong approach </h4><br>  Here is an example of a 100% code coverage test, in which the code is completely untested. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newOrder</span></span></span><span class="hljs-function">) </span></span>{   logger.log(<span class="hljs-string"><span class="hljs-string">`Adding new order </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   DB.save(newOrder);   Mailer.sendMail(newOrder.assignee, <span class="hljs-string"><span class="hljs-string">`A new order was places </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${newOrder}</span></span></span><span class="hljs-string">`</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">approved</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } it(<span class="hljs-string"><span class="hljs-string">"Test addNewOrder, don't use such test names"</span></span>, () =&gt; {   addNewOrder({<span class="hljs-attr"><span class="hljs-attr">asignee</span></span>: <span class="hljs-string"><span class="hljs-string">"John@mailer.com"</span></span>,<span class="hljs-attr"><span class="hljs-attr">price</span></span>: <span class="hljs-number"><span class="hljs-number">120</span></span>}); });<span class="hljs-comment"><span class="hljs-comment">//–ö–æ–¥ –ø–æ–∫—Ä—ã—Ç —Ç–µ—Å—Ç–∞–º–∏ –Ω–∞ 100%, –Ω–æ, –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ, –æ–Ω —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –Ω–µ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω</span></span></code> </pre> <br><h4>  The right approach </h4><br>  Here is a mutation test report generated by the Stryker library.  It allows you to know how much code is untested (this is indicated by the number of "surviving" "mutants"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/037/f6c/9c0/037f6c9c038e09d219c1d06a1b255e4c.jpg"></div><br>  <i><font color="#999999">Stryker Report</font></i> <br><br>  The results of this report allow us, with more confidence than the usual indicators of code coverage of tests, to say that tests work as expected. <br><br><ul><li>  Mutation is a code that was deliberately modified by the Stryker library to test the effectiveness of the test. </li><li>  The number of "killed" "mutants" (killed) shows the number of intentionally created code defects ("mutants"), which were detected during testing. </li><li>  The number of ‚Äúsurvivors‚Äù ‚Äúmutants‚Äù (survived) allows you to find out how many code defects the tests did not detect. </li></ul><br><h2>  <font color="#3AC1EF">Section 4. Continuous Integration, Other Code Quality Indicators</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç22.</font>  <font color="#3AC1EF">Use the linter capabilities and interrupt the project build process when it detects a problem they report</font> </h3><br><h4>  Recommendations </h4><br>  These days, linters are powerful tools that can detect serious code problems.  It is recommended, in addition to some basic rules of linting (such as those implemented by the <a href="https://www.npmjs.com/package/eslint-plugin-standard">eslint-plugin-standard</a> and <a href="https://www.npmjs.com/package/eslint-config-airbnb">eslint-config-airbnb plug-ins</a> ), to use specialized rules.  For example, these are the rules implemented by the <a href="https://www.npmjs.com/package/eslint-plugin-chai-expect">eslint-plugin-chai-expect plugin tools</a> for checking the correctness of test code, these are rules from the <a href="https://www.npmjs.com/package/eslint-plugin-promise%3FactiveTab%3Dreadme">eslint-plugin-promise plugin</a> that control work with promises, these are rules from <a href="https://www.npmjs.com/package/eslint-plugin-security">eslint-plugin-security</a> that check the code for It has dangerous regular expressions.  You can also mention the <a href="https://www.npmjs.com/package/eslint-plugin-you-dont-need-lodash-underscore">eslint-plugin-you-dont-need-lodash-underscore plugin</a> , which allows you to find in the code cases of using methods from external libraries that have analogues in pure JavaScript. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  It is a black day, the project gives constant failures in production, and the logs do not contain information about the error stacks.  What happened?  As it turned out, the fact that the code throws out as an exception is in fact not the object of an error.  As a result, the stack information does not fall into the logs.  As a matter of fact, in such a situation a programmer can either be killed against the wall, or, which is much better, spend 5 minutes setting up the linter, which will easily detect the problem and insure the project against similar troubles that may arise in the future. <br><br><h4>  Wrong approach </h4><br>  Here is the code that, by mistake, throws an ordinary object as an exception, while an <code>Error</code> object is needed here.  Otherwise, the stack data will not be included in the log.  ESLint finds something that could cause production problems by avoiding these problems. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6a/d40/bc0/d6ad40bc0f5e0c09840e3b52e2b878a6.jpg"></div><br>  <i><font color="#999999">ESLint helps to find an error in the code</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç23.</font>  <font color="#3AC1EF">Accelerate feedback through the use of continuous integration by local developers</font> </h3><br><h4>  Recommendations </h4><br>  Are you using a centralized continuous integration system that helps control the quality of the code, testing it, applying a linter, testing it for vulnerabilities?  If so, make it so that developers can run this system locally.  This will allow them to instantly check their code, which speeds up <a href="https://www.gocd.org/2016/03/15/are-you-ready-for-continuous-delivery-part-2-feedback-loops/">feedback</a> and reduces project development time.  Why is this so?  An effective development and testing process involves many cyclically repetitive operations.  The code is tested, then the developer receives a report, then, if necessary, the code is refactored, after which everything repeats.  The faster the feedback loop works, the faster the developers get reports on code testing, the more iterations they can perform to improve this code.  If a test report takes a lot of time, it can lead to a deterioration in the quality of the code.  Let's say someone worked on a module, then started working on something else, then got a report on the module, which indicates that the module needs to be improved.  However, the developer is already busy with completely different things, the developer will not pay enough attention to the problem module. <br><br>  Some CI solution providers (say, <a href="https://circleci.com/docs/2.0/local-cli/">CircleCI</a> ) allow you to run the CI pipeline locally.  Some paid tools, like <a href="https://wallabyjs.com/">Wallaby.js</a> (the author notes that he is not associated with this project), allow you to quickly obtain valuable information about the quality of the code.  In addition, the developer can simply add the corresponding npm script to <code>package.json</code> , which performs code quality checks (tests, analyzes with linters, looks for vulnerabilities), and even uses the package <a href="https://www.npmjs.com/package/concurrently">concurrently</a> to speed up the checks.  Now, in order to comprehensively check the code, it will suffice to execute a single command, like <code>npm run quality</code> , and immediately receive a report.  In addition, if the test of the code indicates the presence of problems in it, you can cancel commits using git hooks (the <a href="https://github.com/typicode/husky">husky</a> library can be useful for solving this problem). <br><br><h4>  Consequences of derogating from recommendations </h4><br>  If the developer receives a report on the quality of the code a day after writing this code, such a report is likely to turn into something like a formal document, and the tests of the code will be divorced from work, not becoming its natural part. <br><br><h4>  The right approach </h4><br>  Here is the npm script that performs the code quality check.  The execution of checks is parallelized.  The script is executed when trying to send a new code to the repository.  In addition, the developer can run it on his own initiative. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"inspect:sanity-testing"</span></span>: <span class="hljs-string"><span class="hljs-string">"mocha **/**--test.js --grep \"sanity\""</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:lint"</span></span>: <span class="hljs-string"><span class="hljs-string">"eslint ."</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:vulnerabilities"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm audit"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:license"</span></span>: <span class="hljs-string"><span class="hljs-string">"license-checker --failOn GPLv2"</span></span>,   <span class="hljs-string"><span class="hljs-string">"inspect:complexity"</span></span>: <span class="hljs-string"><span class="hljs-string">"plato ."</span></span>,     <span class="hljs-string"><span class="hljs-string">"inspect:all"</span></span>: <span class="hljs-string"><span class="hljs-string">"concurrently -c \"bgBlue.bold,bgMagenta.bold,yellow\" \"npm:inspect:quick-testing\" \"npm:inspect:lint\" \"npm:inspect:vulnerabilities\" \"npm:inspect:license\""</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {     <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>,     <span class="hljs-string"><span class="hljs-string">"prepush"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run inspect:all"</span></span>   } }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç24.</font>  <font color="#3AC1EF">Perform end-to-end testing on a realistic production-environment mirror</font> </h3><br><h4>  Recommendations </h4><br>  In the vast ecosystem of Kubernetes, there is still a consensus on the use of tools suitable for the deployment of local environments, although such tools appear quite often.  Here one of the possible approaches is to launch ‚Äúminimized‚Äù Kubernetes using tools like <a href="https://kubernetes.io/docs/setup/minikube/">Minikube</a> or <a href="https://microk8s.io/">MicroK8s</a> , which allow you to create lightweight environments that resemble real ones.  Another approach is testing projects in a remote ‚Äúreal‚Äù Kubernetes environment.  Some CI providers (like <a href="https://codefresh.io/">Codefresh</a> ) allow interaction with the embedded Kubernetes environments, which simplifies the work of the CI pipelines when testing real projects.  Others allow you to work with remote Kubernetes environments. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  The use of various technologies in production and testing requires the support of two development models and leads to the separation of teams of programmers and DevOps specialists. <br><br><h4>  The right approach </h4><br>  Here is an example of a CI chain, which, as they say, on the fly, creates a Kubernetes cluster (this is taken <a href="https://container-solutions.com/dynamic-environments-kubernetes/">from here</a> ). <br><br><pre> <code class="javascript hljs">deploy: stage: deploy image: registry.gitlab.com/gitlab-examples/kubernetes-deploy script: - ./configureCluster.sh $KUBE_CA_PEM_FILE $KUBE_URL $KUBE_TOKEN - kubectl create ns $NAMESPACE - kubectl create secret -n $NAMESPACE docker-registry gitlab-registry --docker-server=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY"</span></span> --docker-username=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_USER"</span></span> --docker-password=<span class="hljs-string"><span class="hljs-string">"$CI_REGISTRY_PASSWORD"</span></span> --docker-email=<span class="hljs-string"><span class="hljs-string">"$GITLAB_USER_EMAIL"</span></span> - mkdir .generated - echo <span class="hljs-string"><span class="hljs-string">"$CI_BUILD_REF_NAME-$CI_BUILD_REF"</span></span> - sed -e <span class="hljs-string"><span class="hljs-string">"s/TAG/$CI_BUILD_REF_NAME-$CI_BUILD_REF/g"</span></span> templates/deals.yaml | tee <span class="hljs-string"><span class="hljs-string">".generated/deals.yaml"</span></span> - kubectl apply --namespace $NAMESPACE -f .generated/deals.yaml - kubectl apply --namespace $NAMESPACE -f templates/my-sock-shop.yaml environment: name: test-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>-ci</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç25.</font>  <font color="#3AC1EF">Strive for parallelization of test execution.</font> </h3><br><h4>  Recommendations </h4><br>  If the testing system is well organized, it will become your faithful friend, round the clock ready to report problems with the code.  For this, tests must be performed very quickly.  In practice, it turns out that the execution of 500 unit tests intensively using a processor in a single-threaded mode takes too much time.  And such tests need to be done quite often.  Fortunately, modern tools for running tests ( <a href="https://github.com/facebook/jest">Jest</a> , <a href="https://github.com/avajs/ava">AVA</a> , an <a href="https://github.com/yandex/mocha-parallel-tests">extension for Mocha</a> ) and CI-platform can perform tests in parallel using several processes, which can significantly improve the speed of receiving test reports.  Some CI platforms even know how to parallelize tests between containers, which further improves the feedback loop.  To successfully parallelize the execution of tests, local or remote, tests should not depend on each other.  Stand-alone tests can easily run in different processes. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  Obtaining test results an hour after sending the code to the repository, while working on new project features, is a great way to reduce the usefulness of test results. <br><br><h4>  The right approach </h4><br>  Thanks to the parallel execution of tests, the <a href="https://github.com/yandex/mocha-parallel-tests">mocha-parallel-test</a> library and the <a href="https://github.com/facebook/jest">Jest</a> framework easily bypass Mocha ( <a href="https://medium.com/dailyjs/javascript-test-runners-benchmark-3a78d4117b4">this is the</a> source of this information). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5f/aa2/e8e/c5faa2e8ee900ae5d3447d510bc1bf8f.png"></div><br>  <i><font color="#999999">Test run performance test</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç26.</font>  <font color="#3AC1EF">Protect yourself from legal problems by using license checks and plagiarism code checks.</font> </h3><br><h4>  Recommendations </h4><br>  Perhaps now you are not particularly concerned about the problems with the law and with plagiarism.  But why not check your project for similar problems?  There are many means for organizing such checks.  For example, it is <a href="https://www.npmjs.com/package/license-checker">license-checker</a> and <a href="https://www.npmjs.com/package/plagiarism-checker">plagiarism-checker</a> (this is a commercial package, but it can be used for free).  Such checks are easy to build into the CI pipeline and check the project, for example, for dependencies with limited licenses, or for the code copied from StackOverflow, and probably violating someone's copyright. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  The developer, quite unintentionally, can use the package with an inappropriate license for his project, or copy the commercial code, which can lead to legal problems. <br><br><h4>  The right approach </h4><br>  Install the license-checker package locally or in a CI environment: <br><br><pre> <code class="javascript hljs">npm install -g license-checker</code> </pre> <br>  We will verify licenses with it, and if he finds what does not suit us, we recognize the check as unsuccessful.  CI-system, finding that something went wrong while checking licenses, will stop the project build. <br><br><pre> <code class="javascript hljs">license-checker --summary --failOn BSD</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/791/cde/326/791cde326f7185df4c78479ef4ab5757.png"></div><br>  <i><font color="#999999">License check</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç27.</font>  <font color="#3AC1EF">Constantly check the project for vulnerable dependencies.</font> </h3><br><h4>  Recommendations </h4><br>  Even highly respected and reliable packages, such as Express, have vulnerabilities.  In order to identify such vulnerabilities, you can use special tools - such as the standard tool for <a href="https://docs.npmjs.com/getting-started/running-a-security-audit">auditing npm-packages</a> or the commercial project <a href="https://snyk.io/">snyk</a> , which has a free version.  These checks, along with others, can be made part of the CI pipeline. <br><br><h4>  Consequences of derogating from recommendations </h4><br>  In order to protect your project from the vulnerabilities of its dependencies without the use of special tools, you will have to constantly monitor publications about such vulnerabilities.  This is a very time consuming task. <br><br><h4>  The right approach </h4><br>  Here are the results of project verification using NPM Audit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/da1/3a9/9d5da13a900a066fbc6c15aba2cc0a0d.png"></div><br>  <i><font color="#999999">Package Inspection Report for Vulnerabilities</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç28.</font>  <font color="#3AC1EF">Automate dependency updating</font> </h3><br><h4>  Recommendations </h4><br>  The road to hell is paved with good intentions.  This idea is perfectly applicable to the <code>package-lock.json</code> , the use of which, by default, blocks the updating of packages.  This happens even in cases when projects are brought to a healthy state with the <code>npm install</code> and <code>npm update</code> commands.  This leads either to the use of obsolete packages, at best, or, at worst, to the appearance of vulnerable code in a project.  Development teams, as a result, rely on either manually updating information about the versions of packages that suit them, or on utilities like <a href="https://www.npmjs.com/package/npm-check-updates">ncu</a> , which, again, are started manually.  The process of updating dependencies is best automated by focusing on using the most reliable versions of the packages used in the project.  There is no one correct solution here, however, a couple of noteworthy approaches can be distinguished in automating package updates.  The first is to introduce something like package checking with <a href="https://docs.npmjs.com/cli/outdated">npm-outdated</a> or <a href="https://www.npmjs.com/package/npm-check-updates">npm-check-updates</a> (ncu) into the CI pipeline.  This will identify obsolete packages and encourage developers to upgrade them.  The second approach is to use commercial tools that check the code and automatically make pull requests to update dependencies.  In the field of automatic updating of dependencies, we face another interesting question that concerns the update policy.  If updated when each new patch is released, the update may place too much stress on the system.  If updated immediately after the release of the next major version of the package, this may lead to the use of unstable solutions in the project (vulnerabilities in many packages are detected exactly in the very first days after the release, <a href="https://nodesource.com/blog/a-high-level-post-mortem-of-the-eslint-scope-security-incident/">read</a> about the eslint-scope incident).  A good package update policy may provide for a certain ‚Äútransitional period‚Äù when the local version will be considered obsolete not immediately after the release of the next new version, but with some delay. –°–∫–∞–∂–µ–º, –ª–æ–∫–∞–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–µ—Ä—Å–∏—è –Ω–µ–∫–æ–µ–≥–æ –ø–∞–∫–µ—Ç–∞ 1.3.1, –Ω–æ –æ–Ω–∞ –ø—Ä–∏–∑–Ω–∞—ë—Ç—Å—è –Ω—É–∂–¥–∞—é—â–µ–π—Å—è –≤ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –Ω–µ —Å –≤—ã—Ö–æ–¥–æ–º –≤–µ—Ä—Å–∏–∏ —ç—Ç–æ–≥–æ –ø–∞–∫–µ—Ç–∞ 1.3.2, –∞ —Ç–æ–ª—å–∫–æ —Å –≤—ã—Ö–æ–¥–æ–º –≤–µ—Ä—Å–∏–∏ 1.3.8. <br><br><h4> –ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è –æ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π </h4><br> –ï—Å–ª–∏ –Ω–µ —É–¥–µ–ª—è—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—é –ø–∞–∫–µ—Ç–æ–≤ —Å–µ—Ä—å—ë–∑–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è, —Ç–æ –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è —Ç–∞–∫, —á—Ç–æ –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –≤–µ—Ä—Å–∏–∏ –ø–∞–∫–µ—Ç–æ–≤, –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –∏—Ö –∞–≤—Ç–æ—Ä–∞–º–∏ –∫–∞–∫ –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ. <br><br><h4> –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ </h4><br> –£—Ç–∏–ª–∏—Ç—É <a href="https://www.npmjs.com/package/npm-check-updates">ncu</a> –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –≤—ã—è—Å–Ω–µ–Ω–∏—è —Ç–æ–≥–æ, –Ω–∞—Å–∫–æ–ª—å–∫–æ –≤–µ—Ä—Å–∏–∏ –ø–∞–∫–µ—Ç–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤ –ø—Ä–æ–µ–∫—Ç–µ, –æ—Ç—Å—Ç–∞—é—Ç –æ—Ç —Å–∞–º—ã—Ö —Å–≤–µ–∂–∏—Ö –≤–µ—Ä—Å–∏–π —ç—Ç–∏—Ö –ø–∞–∫–µ—Ç–æ–≤. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6e/b2a/dcf/e6eb2adcf8720657a4e5c09c34691704.png"></div><br> <i><font color="#999999">–ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞ —Å—Ä–µ–¥—Å—Ç–≤–∞–º–∏ ncu</font></i> <br><br><h3> <font color="#3AC1EF">‚ñç29. –ü—Ä–∏–º–∏—Ç–µ –∫ —Å–≤–µ–¥–µ–Ω–∏—é —Å–ª–µ–¥—É—é—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏, –Ω–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –Ω–∞–ø—Ä—è–º—É—é —Å Node.js</font> </h3><br><h4>  Recommendations </h4><br> –•–æ—Ç—è —ç—Ç–æ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª –∏ –Ω–∞—Ü–µ–ª–µ–Ω –Ω–∞ –≤—Å—ë, —á—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º Node.js-–ø—Ä–æ–µ–∫—Ç–æ–≤, –∑–¥–µ—Å—å –º—ã –ø—Ä–∏–≤–µ–¥—ë–º –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–æ–≤–µ—Ç—ã, –Ω–∞–ø—Ä—è–º—É—é –∫ Node.js –Ω–µ –æ—Ç–Ω–æ—Å—è—â–∏–µ—Å—è. <br><br><ol><li> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å. –í–æ –º–Ω–æ–≥–∏—Ö —Å–ª—É—á–∞—è—Ö —ç—Ç–æ ‚Äî –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ –≤–æ–∑–º–æ–∂–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –Ω–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤ —Å—Ç–∞—Ä—ã—Ö –≤–µ—Ä—Å–∏—è—Ö Jenkins –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω—è—Ç—å –∫–æ–¥ –∏–ª–∏ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å. </li><li> –í—ã–±–∏—Ä–∞–π—Ç–µ —Å–∏—Å—Ç–µ–º—ã, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–µ Docker. </li><li> –í –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å –∑–∞–ø—É—Å–∫–∞–π—Ç–µ —Å–∞–º—ã–µ –±—ã—Å—Ç—Ä—ã–µ —Ç–µ—Å—Ç—ã. –¢–∞–∫, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–∞–π–¥—É—Ç –æ—à–∏–±–∫–∏, –≤—ã –±—ã—Å—Ç—Ä–µ–µ –æ–± —ç—Ç–∏—Ö –æ—à–∏–±–∫–∞—Ö —É–∑–Ω–∞–µ—Ç–µ. –°–≥—Ä—É–ø–ø–∏—Ä—É–π—Ç–µ –±—ã—Å—Ç—Ä—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ª–∏–Ω—Ç–∏–Ω–≥ –∏ –º–æ–¥—É–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã), –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö –ø–æ–∑–≤–æ–ª–∏—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º –±—ã—Å—Ç—Ä–æ –æ—Ü–µ–Ω–∏—Ç—å –∫–æ–¥, –∏, –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏, –æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ –≤–Ω–µ—Å—Ç–∏ –≤ –Ω–µ–≥–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è. </li><li> –ü–æ—Å—Ç–∞—Ä–∞–π—Ç–µ—Å—å —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã —Å–æ –≤—Å–µ–º —Ç–µ–º, —á—Ç–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Å–±–æ—Ä–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞, –±—ã–ª–æ –±—ã —É–¥–æ–±–Ω–æ —Ä–∞–±–æ—Ç–∞—Ç—å. –≠—Ç–æ ‚Äî –æ—Ç—á—ë—Ç—ã –æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏, –æ –ø–æ–∫—Ä—ã—Ç–∏–∏ –∫–æ–¥–∞ —Ç–µ—Å—Ç–∞–º–∏, –æ –º—É—Ç–∞—Ü–∏–æ–Ω–æ–º —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏, —ç—Ç–æ –ª–æ–≥–∏ –∏ –¥—Ä—É–≥–∏–µ –ø–æ–¥–æ–±–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã. </li><li> –°–æ–∑–¥–∞–≤–∞—è –∑–∞–¥–∞–Ω–∏—è –¥–ª—è —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π, —Å—Ç—Ä–µ–º–∏—Ç–µ—Å—å –∫ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –∫–æ–¥–∞. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–º–∏—Ç–æ–≤ –≤ –≤–µ—Ç–∫—É feature, –∏ –µ—â—ë –æ–¥–Ω–æ ‚Äî –¥–ª—è –≤–µ—Ç–∫–∏ master, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ, –º–æ–∂–Ω–æ –ª–∏ –æ–±–ª–µ–≥—á–∏—Ç—å —Å–µ–±–µ –∂–∏–∑–Ω—å –∑–∞ —Å—á—ë—Ç —Å–æ–≤–º–µ—Å—Ç–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–∏–º–∏ –º–µ—Ö–∞–Ω–∏–∑–º–∞–º–∏ –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –∫–æ–¥–∞ (–æ–±—ã—á–Ω–æ —Ç–∞–∫–æ–µ –≤–ø–æ–ª–Ω–µ –≤–æ–∑–º–æ–∂–Ω–æ). </li><li> –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—Å—Ç—Ä–∞–∏–≤–∞–π—Ç–µ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–ø–∏—Å–∞–Ω–∏—è –∑–∞–¥–∞–Ω–∏–π. –ü–æ–¥–æ–±–Ω—ã–µ —Å–≤–µ–¥–µ–Ω–∏—è –Ω–∞–¥–æ –ª–∏–±–æ –∑–∞–≥—Ä—É–∂–∞—Ç—å –∏–∑ –æ—Å–æ–±–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞, –ª–∏–±–æ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∑–∞–¥–∞–Ω–∏—è. </li><li> –°–ª–µ–¥–∏—Ç–µ –∑–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ä–µ–ª–∏–∑–æ–≤. </li><li> –í—ã–ø–æ–ª–Ω—è–π—Ç–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—É—é —Å–±–æ—Ä–∫—É –ø—Ä–æ–µ–∫—Ç–∞ –∏ –ø—Ä–æ–≤–æ–¥–∏—Ç–µ –Ω–∞ –Ω–µ–π (–Ω–∞–ø—Ä–∏–º–µ—Ä, —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–±—Ä–∞–∑ Docker) –≤—Å–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è. </li><li> –ü—Ä–æ–≤–æ–¥–∏—Ç–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ —Å—Ç–∞–±–∏–ª—å–Ω–æ–º –æ–∫—Ä—É–∂–µ–Ω–∏–∏, –∫–æ—Ç–æ—Ä–æ–µ, –º–µ–∂–¥—É —Å–±–æ—Ä–∫–∞–º–∏, –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –≤ —Ç–∞–∫–æ–º –æ–∫—Ä—É–∂–µ–Ω–∏–∏ –º–æ–∂–Ω–æ –¥–µ—Ä–∂–∞—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é <code>node_modules</code> . </li></ol><br><h4> –ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è –æ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π </h4><br> –ù–µ –æ–±—Ä–∞—â–∞—è –≤–Ω–∏–º–∞–Ω–∏—è –Ω–∞ —ç—Ç–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏, –≤—ã –∑–∞–∫—Ä—ã–≤–∞–µ—Ç–µ –≥–ª–∞–∑–∞ –Ω–∞ –æ–ø—ã—Ç, –Ω–∞—Ä–∞–±–æ—Ç–∫–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ –∑–∞–Ω—è–ª–∞ –º–Ω–æ–≥–∏–µ –≥–æ–¥—ã. <br><br><h3> <font color="#3AC1EF">‚ñç30. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏—é –º–∞—Ç—Ä–∏—Ü—ã —Å–±–æ—Ä–∫–∏</font> </h3><br><h4>  Recommendations </h4><br> –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞ –±—É–¥–µ—Ç —Ç–µ–º —É—Å–ø–µ—à–Ω–µ–µ, —á–µ–º –±–æ–ª—å—à–µ –∫–æ–¥–∞ —É–¥–∞—ë—Ç—Å—è –ø–æ–∫—Ä—ã—Ç—å —Ç–µ—Å—Ç–∞–º–∏. –ï—Å–ª–∏ –≤—ã –∑–∞–Ω—è—Ç—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–æ–π –ø—Ä–æ–µ–∫—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Å—Ä–µ–¥–∞—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ä—Å–∏—è—Ö Node.js –∏ —Å —Ä–∞–∑–Ω—ã–º–∏ –°–£–ë–î, —Å–∏—Å—Ç–µ–º–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –¥–æ–ª–∂–Ω–∞ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –≤–æ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö —Ç–∞–∫–∏—Ö —Å—Ä–µ–¥. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ CI-—Å–∏—Å—Ç–µ–º—ã, –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ–¥–æ–±–Ω—ã—Ö –∏—Å–ø—ã—Ç–∞–Ω–∏–π, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç —Ç–∞–∫ –Ω–∞–∑—ã–≤–∞–µ–º—É—é ¬´–º–∞—Ç—Ä–∏—Ü—É —Å–±–æ—Ä–∫–∏¬ª. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ, —Ö–æ—Ç—è —Å–∞–º–∏ —ç—Ç–æ –∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç, –ø–æ–∑–≤–æ–ª—è—é—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–ª–∞–≥–∏–Ω—ã, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–µ —ç—Ç—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å. –ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∞—à–∏ –∫–ª–∏–µ–Ω—Ç—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç mySQL, –∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ ‚Äî Postgres. –ö —Ç–æ–º—É –∂–µ, —É –Ω–∏—Ö –º–æ–≥—É—Ç –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —Ä–∞–∑–ª–∏—á–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ Node.js, —Å–∫–∞–∂–µ–º ‚Äî 8, 9 –∏ 10. –ò—Å–ø–æ–ª—å–∑—É—è –º–∞—Ç—Ä–∏—Ü—É —Å–±–æ—Ä–∫–∏ –º–æ–∂–Ω–æ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç –≤–æ –≤—Å–µ—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞—Ö —Å—Ä–µ–¥, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –æ–Ω –º–æ–∂–µ—Ç –æ–∫–∞–∑–∞—Ç—å—Å—è. –î–µ–ª–∞–µ—Ç—Å—è —ç—Ç–æ –ø—É—Ç—ë–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ CI-—Å–∏—Å—Ç–µ–º—ã. <br><br><h4> –ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –æ—Ç—Å—Ç—É–ø–ª–µ–Ω–∏—è –æ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π </h4><br> –ï—Å–ª–∏ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –ø—Ä–æ–µ–∫—Ç–∞ –≤–æ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è—Ö, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –æ–Ω –º–æ–∂–µ—Ç –≤—Å—Ç—Ä–µ—Ç–∏—Ç—å—Å—è, –º–æ–∂–Ω–æ —Å—Ç–æ–ª–∫–Ω—É—Ç—å—Å—è —Å –æ—à–∏–±–∫–æ–π, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–æ—è–≤–ª—è–µ—Ç—Å—è –ª–∏—à—å –≤ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö —É—Å–ª–æ–≤–∏—è—Ö. –ü—Ä–∏—á—ë–º, –≤–µ—Ä–æ—è—Ç–Ω–µ–µ –≤—Å–µ–≥–æ, —ç—Ç–∞ –æ—à–∏–±–∫–∞ –ø—Ä–æ—Å–∫–æ—á–∏—Ç –≤ –ø—Ä–æ–¥–∞–∫—à–Ω. <br><br><h4> –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ </h4><br> –í–æ—Ç –ø—Ä–∏–º–µ—Ä –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ CI-—Å–∏—Å—Ç–µ–º—ã Travis –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ä–∞–∑–Ω—ã—Ö –≤–µ—Ä—Å–∏–π Node.js. <br><br><pre> <code class="javascript hljs">language: node_js node_js: - <span class="hljs-string"><span class="hljs-string">"7"</span></span> - <span class="hljs-string"><span class="hljs-string">"6"</span></span> - <span class="hljs-string"><span class="hljs-string">"5"</span></span> - <span class="hljs-string"><span class="hljs-string">"4"</span></span> install: - npm install script: - npm run test</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br> –í —ç—Ç–æ–º –º–∞—Ç–µ—Ä–∏–∞–ª–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–ª–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏, –∫–∞—Å–∞—é—â–∏–µ—Å—è —Å–∏—Å—Ç–µ–º –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏, –æ—Ü–µ–Ω–∫–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–µ—Å—Ç–æ–≤ –∏ –∞–Ω–∞–ª–∏–∑–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞. –ù–∞–¥–µ–µ–º—Å—è, –≤–∞–º –ø—Ä–∏–≥–æ–¥–∏—Ç—Å—è —Ç–æ, –æ —á—ë–º –º—ã –∑–¥–µ—Å—å —Ä–∞—Å—Å–∫–∞–∑–∞–ª–∏. <br><br>  <b>Dear readers!</b> –ö–∞–∫–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤—ã –ø–æ–ª—å–∑—É–µ—Ç–µ—Å—å? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/435464/">https://habr.com/ru/post/435464/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>