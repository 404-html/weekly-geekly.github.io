<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Signing a PDF on JS and inserting a signature on C # using Krypto PRO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So. The task came. Using a browser, invite the user to sign a PDF with an electronic signature (hereinafter referred to as ES). The user must have a t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Signing a PDF on JS and inserting a signature on C # using Krypto PRO</h1><div class="post__text post__text-html js-mediator-article">  So.  The task came.  Using a browser, invite the user to sign a PDF with an electronic signature (hereinafter referred to as ES).  The user must have a token containing a certificate, public and private key.  Next on the server you need to insert a signature in the PDF document.  After that, you need to check the signature for validity.  As back-end we use ASP.NET and accordingly C #. <br><br>  All salt in that it is necessary to use the signature in the CAdES-X Long Type 1 format, and the Russian GOST R 34.10-2001, GOST R 34.10-2012, etc.  In addition, there can be more than one signatures, that is, users can sign a file in turn.  At the same time, the previous signatures must remain valid. <br><a name="habracut"></a><br>  In the process of solving the problem, we decided to make it more difficult for us to reduce the amount of transmitted data to the client.  Pass only the hash of the document, but not the document itself. <br><br>  In the source code I will omit moments of little significance for the topic, leaving only that with regard to cryptography.  I will give the code on JS only for normal browsers whose JS engines support Promise and function generator.  I think someone needs for IE will write themselves (I had to "through I do not want"). <br><br>  What do you need: <br><br><ol><li>  The user must obtain a pair of keys and a certificate. </li><li>  The user must install the plug-in from Crypto PRO.  Without this, using JS, we will not be able to work with a cryptographic provider. </li></ol><br>  Remarks: <br><br><ol><li>  For tests, I had a certificate issued by a test CA of Crypto PRO and a normal token received by one of our employees (at the time of writing the article ~ 1500r with an annual license for Crypto PRO and two certificates: but ‚Äúnew‚Äù and ‚Äúold‚Äù GOST) </li><li>  They say that the plug-in can work with ViPNet, but I have not tested it. </li></ol><br>  Now we will assume that we have a PDF ready for signing on the server. <br>  Add a script from Crypto PRO to the page: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/Scripts/cadesplugin_api.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Next we need to wait until the cadesplugin object is formed. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.cadespluginLoaded = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cadesplugin.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.cadespluginLoaded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; });</code> </pre><br>  We request from the server hash.  For this, we still need to know what certificate, and therefore the user will sign the algorithm.  A small remark: I combined all the functions and "variables" for working with client-side cryptography into a CryptographyObject object. <br><br>  The method of filling in the certificates field of the CryptographyObject object: <br><br><pre> <code class="javascript hljs"> fillCertificates: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">failCallback</span></span></span><span class="hljs-function">) </span></span>{ cadesplugin.async_spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oStore = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cadesplugin.CreateObjectAsync(<span class="hljs-string"><span class="hljs-string">"CAPICOM.Store"</span></span>); oStore.Open(cadesplugin.CAPICOM_CURRENT_USER_STORE, cadesplugin.CAPICOM_MY_STORE, cadesplugin.CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> certs = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> oStore.Certificates; certs = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> certs.Find(cadesplugin.CAPICOM_CERTIFICATE_FIND_TIME_VALID); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> certsCount = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> certs.Count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= certsCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cert = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> certs.Item(i); CryptographyObject.certificates.push(cert); } oStore.Close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (exc) { failCallback(exc); } }); }</code> </pre><br>  Comment: try to open the certificate store.  At this point, the user's system will issue a warning that the site is trying to do something with certificates, cryptography, and other magical incomprehensible nonsense.  The user here will need to click "Yes" <br>  Next, we get certificates that are valid in time (not expired) and add them to the array of certificates.  This must be done because of the asynchronous nature of the cadesplugin (for IE, everything is different;)). <br><br>  Method to get hash: <br><br><pre> <code class="javascript hljs">getHash: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">certIndex, successCallback, failCallback, –∫–∞–∫–∏–µ-—Ç–æ –µ—â—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cadesplugin.async_spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cert = CryptographyObject.certificates[certIndex]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> certPublicKey = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> cert.PublicKey(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> certAlgorithm = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> certPublicKey.Algorithm; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> algorithmValue = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> certAlgorithm.Value; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hashAlgorithm; <span class="hljs-comment"><span class="hljs-comment">//–æ–ø—Ä–µ–¥–µ–ª—è–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è –ø–æ –¥–∞–Ω–Ω—ã–º –∏–∑ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –∏ –ø–æ–ª—É—á–∞–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è if (algorithmValue === "1.2.643.7.1.1.1.1") { hashAlgorithm = "2012256"; } else if (algorithmValue === "1.2.643.7.1.1.1.2") { hashAlgorithm = "2012512"; } else if (algorithmValue === "1.2.643.2.2.19") { hashAlgorithm = "3411"; } else { failCallback("–†–µ–∞–ª–∏–∑—É–µ–º—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞."); return; } $.ajax({ url: "/Services/SignService.asmx/GetHash", method: "POST", contentType: "application/json; charset=utf-8 ", dataType: "json", data: JSON.stringify({ //–∫–∞–∫–∏–µ-—Ç–æ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞ //–Ω–µ –∑–∞–±—É–¥–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ –∏–º–µ–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω—É–∂–Ω—ã–µ –ø—Ä–∞–≤–∞ hashAlgorithm: hashAlgorithm, }), complete: function (response) { //–ø–æ–ª—É—á–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞, –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å –Ω–∞ —Å–µ—Ä–≤–µ—Ä if (response.status === 200) { CryptographyObject.signHash(response.responseJSON, function(data) { $.ajax({ url: CryptographyObject.signServiceUrl, method: "POST", contentType: "application/json; charset=utf-8", dataType: "json", data: JSON.stringify({ Signature: data.Signature, //–∫–∞–∫–∏–µ-—Ç–æ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞ //–Ω–µ –∑–∞–±—É–¥–µ–º –ø—Ä–æ —Å–µ—Ä–≤–µ—Ä–Ω—É—é –≤–∞–ª–∏–¥–∞—Ü–∏—é –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é }), complete: function(response) { if (response.status === 200) successCallback(); else failCallback(); } }); }, certIndex); } else { failCallback(); } } }); }); } catch (exc) { failCallback(exc); } }</span></span></code> </pre><br>  Comment: pay attention to cadesplugin.async_spawn, the generator function is passed to it, where next () is sequentially called, which leads to the transition to yield. <br>  Thus it turns out a certain analogue of async-await from C #.  Everything looks synchronous, but it works asynchronously. <br><br>  Now what happens on the server when hash is requested. <br><br>  Firstly, you need to install the nuext package iTextSharp (at the time of writing, the current version 5.5.13 should become) <br><br>  Secondly, CryptoPro.Sharpei is needed, it goes to work with the Crypto PRO .NET SDK <br><br>  Now you can get hash <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//–æ–ø—Ä–µ–¥–µ–ª–∏–º hash-–∞–ª–≥–æ—Ä–∏—Ç–º HashAlgorithm hashAlgorithm; switch (hashAlgorithmName) { case "3411": hashAlgorithm = new Gost3411CryptoServiceProvider(); break; case "2012256": hashAlgorithm = new Gost3411_2012_256CryptoServiceProvider(); break; case "2012512": hashAlgorithm = new Gost3411_2012_512CryptoServiceProvider(); break; default: GetLogger().AddError("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è", $"hashAlgorithmName: {hashAlgorithmName}"); return HttpStatusCode.BadRequest; } //–ø–æ–ª—É—á–∏–º hash –≤ —Å—Ç—Ä–æ–∫–æ–≤–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–∏, –ø–æ–Ω—è—Ç–Ω–æ–º cadesplugin string hash; using (hashAlgorithm) //downloadResponse.RawBytes - –ø—Ä–æ—Å—Ç–æ –º–∞—Å—Å–∏–≤ –±–∞–π—Ç –∏—Å—Ö–æ–¥–Ω–æ–≥–æ PDF —Ñ–∞–π–ª–∞ using (PdfReader reader = new PdfReader(downloadResponse.RawBytes)) { //–∏—â–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–¥–ø–∏—Å–∏ int existingSignaturesNumber = reader.AcroFields.GetSignatureNames().Count; using (MemoryStream stream = new MemoryStream()) { //–¥–æ–±–∞–≤–ª—è–µ–º –ø—É—Å—Ç–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –Ω–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∏ using (PdfStamper st = PdfStamper.CreateSignature(reader, stream, '\0', null, true)) { PdfSignatureAppearance appearance = st.SignatureAppearance; //–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞–¥–æ –º–µ–Ω—è—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–æ–¥–ø–∏—Å–µ–π, —á—Ç–æ–± –æ–Ω–∏ –Ω–µ –Ω–∞–ª–æ–∂–∏–ª–∏—Å—å –¥—Ä—É–≥ –Ω–∞ –¥—Ä—É–≥–∞ appearance.SetVisibleSignature(new Rectangle(36, 100, 164, 150), reader.NumberOfPages, //–∑–∞–¥–∞—ë–º –∏–º—è –ø–æ–ª—è, –æ–Ω–æ –ø–æ—Ç–æ–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –ø–æ–¥–ø–∏—Å–∏ $"{SignatureFieldNamePrefix}{existingSignaturesNumber + 1}"); //—Å–æ–æ–±—â–∞–µ–º, —á—Ç–æ –ø–æ–¥–ø–∏—Å—å –ø—Ä–∏–¥—ë—Ç –∏–∑–≤–Ω–µ ExternalBlankSignatureContainer external = new ExternalBlankSignatureContainer(PdfName.ADOBE_PPKLITE, PdfName.ADBE_PKCS7_DETACHED); //—Ç—Ä–µ—Ç–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä - —Å–∫–æ–ª—å–∫–æ –º–µ—Å—Ç–∞ –≤ –±–∞–π—Ç–∞—Ö –º—ã –≤—ã–¥–µ–ª—è–µ–º –ø–æ–¥ –ø–æ–¥–ø–∏—Å—å //—è –≤—ã–¥–µ–ª—è—é –º–Ω–æ–≥–æ, —Ç.–∫. CAdES-X Long Type 1 —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –ø–æ —Ü–µ–ø–æ—á–∫–µ –¥–æ —Å–∞–º–æ–≥–æ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ —Ü–µ–Ω—Ç—Ä–∞ MakeSignature.SignExternalContainer(appearance, external, 65536); //–ø–æ–ª—É—á–∞–µ–º –ø–æ—Ç–æ–∫, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –∫–æ—Ç–æ—Ä—É—é –º—ã —Ö–æ—Ç–∏–º –ø–æ–¥–ø–∏—Å—ã–≤–∞—Ç—å using (Stream contentStream = appearance.GetRangeStream()) { //–≤—ã—á–∏—Å–ª—è–µ–º hash –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –µ–≥–æ –≤ —Å—Ç—Ä–æ–∫—É, –ø–æ–Ω—è—Ç–Ω—É—é cadesplugin hash = string.Join(string.Empty, hashAlgorithm.ComputeHash(contentStream).Select(x =&gt; x.ToString("X2"))); } } //—Å–æ—Ö—Ä–∞–Ω—è–µ–º stream –∫—É–¥–∞ —Ö–æ—Ç–∏–º, –æ–Ω –Ω–∞–º –ø—Ä–∏–≥–æ–¥–∏—Ç—å—Å—è, —á—Ç–æ –±—ã –≤—Å—Ç–∞–≤–∏—Ç—å —Ç—É–¥–∞ –ø–æ–¥–ø–∏—Å—å } }</span></span></code> </pre><br>  On the client, having received hash from the server we sign it <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//certIndex - –∏–Ω–¥–µ–∫—Å –≤ –º–∞—Å—Å–∏–≤–µ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤. –ù–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –∏–º–µ–Ω–Ω–æ —ç—Ç–æ–≥–æ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ –º—ã –ø–æ–ª—É—á–∞–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º –∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–ª–∏ hash –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ signHash: function (data, callback, certIndex, failCallback) { try { cadesplugin.async_spawn(function*() { certIndex = certIndex | 0; let oSigner = yield cadesplugin.CreateObjectAsync("CAdESCOM.CPSigner"); let cert = CryptographyObject.certificates[certIndex]; oSigner.propset_Certificate(cert); oSigner.propset_Options(cadesplugin.CAPICOM_CERTIFICATE_INCLUDE_WHOLE_CHAIN); //—Ç—É—Ç –Ω–∞–¥–æ —É–∫–∞–∑–∞—Ç—å –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å TSP —Å–µ—Ä–≤–µ—Ä–∞. –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤—ã–π –æ—Ç –ö—Ä–∏–ø—Ç–æ –ü–†–û oSigner.propset_TSAAddress("https://www.cryptopro.ru/tsp/"); let hashObject = yield cadesplugin.CreateObjectAsync("CAdESCOM.HashedData"); let certPublicKey = yield cert.PublicKey(); let certAlgorithm = yield certPublicKey.Algorithm; let algorithmValue = yield certAlgorithm.Value; if (algorithmValue === "1.2.643.7.1.1.1.1") { yield hashObject.propset_Algorithm(cadesplugin.CADESCOM_HASH_ALGORITHM_CP_GOST_3411_2012_256); oSigner.propset_TSAAddress(CryptographyObject.tsaAddress2012); } else if (algorithmValue === "1.2.643.7.1.1.1.2") { yield hashObject.propset_Algorithm(cadesplugin.CADESCOM_HASH_ALGORITHM_CP_GOST_3411_2012_512); oSigner.propset_TSAAddress(CryptographyObject.tsaAddress2012); } else if (algorithmValue === "1.2.643.2.2.19") { yield hashObject.propset_Algorithm(cadesplugin.CADESCOM_HASH_ALGORITHM_CP_GOST_3411); oSigner.propset_TSAAddress(CryptographyObject.tsaAddress2001); } else { alert("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç —ç—Ç–∏–º —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–º"); return; } //–≤ –æ–±—ä–µ–∫—Ç –æ–ø–∏—Å–∞–Ω–∏—è hash –≤—Å—Ç–∞–≤–ª—è–µ–º —É–∂–µ –≥–æ—Ç–æ–≤—ã–π hash —Å —Å–µ—Ä–≤–µ—Ä–∞ yield hashObject.SetHashValue(data.Hash); let oSignedData = yield cadesplugin.CreateObjectAsync("CAdESCOM.CadesSignedData"); oSignedData.propset_ContentEncoding(cadesplugin.CADESCOM_BASE64_TO_BINARY); //—Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è –≤ base64 let signatureHex = yield oSignedData.SignHash(hashObject, oSigner, cadesplugin.CADESCOM_CADES_X_LONG_TYPE_1); data.Signature = signatureHex; callback(data); }); } catch (exc) { failCallback(exc); } }</span></span></code> </pre><br>  Comment: send the received signature to the server (see above) <br><br>  Well, finally insert the signature into the document on the server side <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//–≤—Å—è–∫–∏–µ –Ω—É–∂–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ //downloadResponse.RawBytes - —Ä–∞–Ω–µ–µ —Å–æ–∑–¥–∞–Ω–Ω—ã–π PDF —Å –ø—É—Å—Ç—ã–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–º –¥–ª—è –ø–æ–¥–ø–∏—Å–∏ using (PdfReader reader = new PdfReader(downloadResponse.RawBytes)) { using (MemoryStream stream = new MemoryStream()) { //requestData.Signature - —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ –ø–æ–¥–ø–∏—Å—å –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ IExternalSignatureContainer external = new SimpleExternalSignatureContainer(Convert.FromBase64String(requestData.Signature)); //lastSignatureName - –∏–º—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞, –∫–æ—Ç–æ—Ä–æ–µ –º—ã –æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ hash MakeSignature.SignDeferred(reader, lastSignatureName, stream, external); //—Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–¥–ø–∏—Å–∞–Ω–Ω—ã–π —Ñ–∞–π–ª } }</span></span></code> </pre><br>  Comment: SimpleExternalSignatureContainer is the simplest class that implements the IExternalSignatureContainer interface. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –≤–Ω–µ—à–Ω–µ–π –ø–æ–¥–ø–∏—Å–∏ </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private class SimpleExternalSignatureContainer : IExternalSignatureContainer { private readonly byte[] _signedBytes; public SimpleExternalSignatureContainer(byte[] signedBytes) { _signedBytes = signedBytes; } public byte[] Sign(Stream data) { return _signedBytes; } public void ModifySigningDictionary(PdfDictionary signDic) { } }</span></span></code> </pre><br>  Actually with the signing of the PDF on it all.  The check will be described in the continuation of the article.  I hope she will ... <br><br><div class="spoiler">  <b class="spoiler_title">sources of inspiration</b> <div class="spoiler_text">  <a href="https://www.cryptopro.ru/sites/default/files/products/cades/demopage/cades_xlong_sample.html">www.cryptopro.ru/sites/default/files/products/cades/demopage/cades_xlong_sample.html</a> <br>  <a href="http://cpdn.cryptopro.ru/content/cades/plugin-activation.html">cpdn.cryptopro.ru/content/cades/plugin-activation.html</a> <br>  <a href="https://www.cryptopro.ru/forum2/default.aspx%3Fg%3Dposts%26t%3D11119">www.cryptopro.ru/forum2/default.aspx?g=posts&amp;t=11119</a> <br>  <a href="https://www.cryptopro.ru/forum2/default.aspx%3Fg%3Dposts%26t%3D3691%26p%3D21">www.cryptopro.ru/forum2/default.aspx?g=posts&amp;t=3691&amp;p=21</a> <br>  <a href="http://cpdn.cryptopro.ru/default.asp%3Furl%3Dcontent/cades/plugin-samples-raw-signature.html">cpdn.cryptopro.ru/default.asp?url=content/cades/plugin-samples-raw-signature.html</a> <br>  <a href="http://cpdn.cryptopro.ru/default.asp%3Furl%3Dcontent/cades/plugin.html">cpdn.cryptopro.ru/default.asp?url=content/cades/plugin.html</a> <br>  <a href="http://itextsupport.com/apidocs/itext5/5.5.9/com/itextpdf/text/pdf/PdfStamper.html">itextsupport.com/apidocs/itext5/5.5.9/com/itextpdf/text/pdf/PdfStamper.html#createSignature-com.itextpdf.text.pdf.PdfReader-java.io.OutputStream-char-java.io.File- boolean-</a> <br></div></div><br><br>  <b>Made corrections from the comment about getting the Oid signature algorithm.</b>  <b>thank</b> </div><p>Source: <a href="https://habr.com/ru/post/426087/">https://habr.com/ru/post/426087/</a></p>
<section class="all-articles-navigation-panel js-all-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>