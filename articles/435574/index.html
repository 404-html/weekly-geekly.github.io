<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does zig work?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: this post was published on the author‚Äôs blog on March 15, 2018. As the language evolves, its syntax may currently vary. Everythin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <div class="page-header-logo-container"></div>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does zig work?</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: this post was published on the author‚Äôs blog on March 15, 2018.</i>  <i>As the language evolves, its syntax may currently vary.</i>  <i>Everything described refers to Zig 0.2.0, the current version of the language is Zig 0.3.0.</i> <i><br><br></i>  <i><a href="https://github.com/jfo/zigf/commit/7b1c563a9bd20e084243bfa0c7435e3cb468ccf2">I contacted the author of the post, and he kindly provided a link to the repository with the current version of the source code of the project in Zig 0.3.0</a></i> <i><br></i> <br>  Hello!  Let's write the Brainfuck interpreter!  ‚ÄúWhy?‚Äù You may ask, but you will not find an answer here. <br><br>  I'll do it on <a href="https://ziglang.org/">Zig</a> . <br><img src="https://habrastorage.org/webt/p2/l1/zs/p2l1zsmnlu7j_yqwm6fczu4ycay.jpeg"><br><h3>  Zig is ... </h3><br>  ... a new programming language.  He is still in beta, and is developing rapidly.  If you‚Äôve seen Zig code before, the code in this post may seem a little different.  He is really different!  Zig 0.2.0 just came out, coinciding with the release of <a href="http://releases.llvm.org/6.0.0/docs/ReleaseNotes.html">LLVM 6 a</a> few weeks ago, and includes many syntax changes and general language enhancements.  Mostly, many ‚Äúspells‚Äù have been replaced by keywords.  See <a href="https://ziglang.org/download/0.2.0/release-notes.html">here</a> for a deeper explanation of all the changes! <br><br>  Zig is designed <a href="https://andrewkelley.me/post/zig-already-more-knowable-than-c.html">to be readable</a> , and relatively intuitive for those familiar with compiled and typed languages, such as C, C ++, and, in some respects, Rust. <br><br>  The code was compiled and tested with Zig 0.2.0, which is available right now, <a href="https://ziglang.org/download/">through various channels</a> , including homebrew, if you are on OSX: brew install zig. <br><a name="habracut"></a><br><h3>  Let's start </h3><br>  To learn how Brainfuck works, look <a href="https://blog.jfo.click/how-brainfuck-works/">here</a> .  There is almost nothing to learn, but it is a <a href="https://en.wikipedia.org/wiki/Turing_completeness">turing-complete</a> language, which means that you can write <a href="https://blog.jfo.click/fizzbuzz-in-brainfuck-part-one/">anything</a> on it. <br><br>  I posted the code <a href="https://github.com/jfo/zigf">here</a> in case you want to see the final product or early commits. <br><br>  Zig is a compiled language.  When you compile a program, the resulting binary (if you compile the executable binary, not the library) must have a main function that denotes an input point. <br><br>  So‚Ä¶ <br><br><pre><code class="plaintext hljs">// main.zig fn main() void { }</code> </pre> <br>  ... and run ... <br><br><pre> <code class="bash hljs">$ zig build-exe main.zig</code> </pre> <br>  ... gives ... <br><br><pre> <code class="bash hljs">/zig/std/special/bootstrap.zig:70:33: error: <span class="hljs-string"><span class="hljs-string">'main'</span></span> is private /zigfuck/main.zig:2:1: note: declared here</code> </pre> <br>  main must be declared public to be visible outside the module ... <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { }</code> </pre> <br>  Let the brainfuck program use an array of 30,000 bytes as memory, I will make such an array. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8; }</code> </pre> <br>  I can declare a constant (const) or a variable (var).  Here, I declared mem as an array of 30,000 unsigned (u) bytes (8 bits). <br><br>  This is not compiled. <br><br><pre> <code class="bash hljs">/main.zig:3:5: error: variables must be initialized</code> </pre> <br>  An equivalent C program would compile normally: I can declare a variable without initialization, but Zig forces me to make a decision now, at the time of declaration of the variable.  I may not care what is written into it, but I have to explicitly indicate this.  I will do this by initializing the variable to an undefined value. <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem: [30000]u8 = undefined; }</code> </pre> <br>  Initializing a variable with an undefined value makes no guarantees about the value of the variable in memory.  This is the same as an uninitialized declaration of a variable in C, except that it is necessary to indicate this explicitly. <br><br>  But maybe I care how to initialize this memory.  Perhaps I want to have a guarantee that zeros or some arbitrary value are written there.  In this case, I must also explicitly state this: <br><br><pre> <code class="plaintext hljs">// main.zig pub fn main() void { const mem = []u8{0} ** 30000; }</code> </pre> <br>  It may seem strange, but ** is the operator used to extend arrays.  I declare an array of 0 bytes, and then extend it by 30,000, and get the final initialization value of 30,000 zero bytes.  This operation occurs once <i>at compile time</i> .  comptime is one of Zig's big ideas, and I‚Äôll get back to it in one of the following posts. <br><br>  Now let's write a program on brainfuck, which does nothing but increment the first memory slot five times! <br><br><pre> <code class="plaintext hljs">pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; }</code> </pre> <br>  In Zig, strings are byte arrays.  I should not declare src as a byte array, because the compiler implies this.  This is optional, but if you want, then it is possible: <br><br><pre> <code class="plaintext hljs">const src: [5]u8 = "+++++";</code> </pre> <br>  This will compile normally.  However, this: <br><br><pre> <code class="plaintext hljs">const src: [6]u8= "+++++";</code> </pre> <br>  will not be. <br><br><pre> <code class="bash hljs">main.zig:5:22: error: expected <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'[6]u8'</span></span>, found <span class="hljs-string"><span class="hljs-string">'[5]u8'</span></span></code> </pre> <br>  Another note: since strings are just arrays, they do not end in zero.  However, you can declare a null-terminated string C. As a literal, it will look like this: <br><br><pre> <code class="plaintext hljs">c"Hello I am a null terminated string";</code> </pre> <br><h3>  For the common good ... </h3><br>  I want to do <i>something</i> with each character in the string.  I can do it!  At the beginning of main.zig, I import some functions from the standard library: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn;</code> </pre> <br>  <a href="https://habr.com/users/import/" class="user_link">import</a> , like virtually everything that starts with the @ sign, is a <a href="https://ziglang.org/documentation/master/">built-in compiler function</a> .  Such features are always globally available.  The import here works like javascript - you can import anything by digging into the namespace and extract from there any publicly available functions or variables.  In the example above, I directly import the warn function and assign it, suddenly, to the constant constant.  Now you can call it.  This is a common pattern: we import directly from the std namespace and then either call std.debug.warn () or assign it to the variable warn.  It looks like this: <br><br><pre> <code class="plaintext hljs">const std = @import("std"); const warn = std.debug.warn;</code> </pre> <br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; // main.zig pub fn main() void { const mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { warn("{}", c); } }</code> </pre> <br>  During debugging and initial development and testing, I just want to print something on the screen.  Zig is <a href="https://ziglang.org/documentation/master/">error-prone</a> , and stdout is also prone to errors.  I don't want to do this right now, and I can type directly into stderr with warn, which we imported from the standard library. <br><br>  warn accepts a string with formatting like printf in C!  The code above will print: <br><br><pre> <code class="plaintext hljs">4343434343</code> </pre> <br>  43 - ascii character code +.  I can also write: <br><br><pre> <code class="plaintext hljs">warn("{c}", c);</code> </pre> <br>  and to get: <br><br><pre> <code class="plaintext hljs">+++++</code> </pre> <br>  So, we initialized the memory space, and wrote the program.  Now we are implementing the language itself.  I'll start with +, and replace the body of the for loop with switch: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1 } }</code> </pre> <br>  I get two errors: <br><br><pre> <code class="plaintext hljs">/main.zig:10:7: error: switch must handle all possibilities switch(c) { ^ /main.zig:11:25: error: cannot assign to constant '+' =&gt; mem[0] += 1 ^</code> </pre> <br>  Of course, I can not assign a new value to a variable, which is a constant!  mem needs to be made a variable ... <br><br><pre> <code class="plaintext hljs">var mem = []u8{0} ** 30000;</code> </pre> <br>  as in the case of other errors, my <a href="https://ziglang.org/documentation/master/">switch</a> construction should know what to do if the character is not equal to +, even if nothing needs to be done.  In my case, this is exactly what I want.  I fill this case with an empty block: <br><br><pre> <code class="plaintext hljs">for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } }</code> </pre> <br>  Now I can compile the program.  Call at the end of warn and run: <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; for (src) |c| { switch(c) { '+' =&gt; mem[0] += 1, else =&gt; {} } } warn("{}", mem[0]); }</code> </pre> <br>  I get the number 5 printed in <a href="https://en.wikipedia.org/wiki/Standard_streams">stderr</a> , as I expected. <br><br><h3>  Go ahead‚Ä¶ </h3><br>  Similarly, doing support. <br><br><pre> <code class="plaintext hljs">switch(c) { '+' =&gt; mem[0] += 1, '-' =&gt; mem[0] -= 1, else =&gt; {} }</code> </pre> <br>  To use the&gt; and &lt;you need to use an additional variable that serves as a "pointer" in memory, which I allocated for the custom brainfuck program. <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0;</code> </pre> <br>  Since an unsigned 16-bit can be a maximum of 65535, it is more than enough to index 30,000 bytes of address space. <br><br><blockquote>  <i>in fact, 15 bits would be enough for us, which allows us to address 32767 bytes.</i>  <i>Zig allows for types with <a href="https://ziglang.org/documentation/master/">different widths</a> , but not u15 yet.</i> <i><br><br></i>  <i>you can actually do u15 like this:</i> <i><br><br></i> <pre> <code class="plaintext hljs">const u15 = @IntType(false, 15):</code> </pre> <br>  <a href="https://github.com/ziglang/zig/issues/745">It is proposed</a> to make any [iu] \ d + type be valid as an integer type. </blockquote><br>  Now instead of using mem [0], I can use this variable. <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1,</code> </pre> <br>  &lt;and&gt; simply increment and decrement this pointer. <br><br><pre> <code class="plaintext hljs">'&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1,</code> </pre> <br>  Wonderful.  We can now write a real program! <br><br><h3>  Checking 1,2,3 </h3><br>  Zig has a built-in test mechanism.  Anywhere in any file I can write a test block: <br><br><pre> <code class="plaintext hljs">test "Name of Test" { // test code }</code> </pre> <br>  and run the test from the command line: zig test $ FILENAME.  The rest of the test blocks are the same as normal code. <br><br>  Let's look at this: <br><br><pre> <code class="plaintext hljs">// test.zig test "testing tests" {} zig test test.zig Test 1/1 testing tests...OK</code> </pre> <br>  Of course, an empty test is useless.  I can use assert to actually confirm the execution of the tests. <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "test true" { assert(true); } test "test false" { assert(false); }</code> </pre> <br><pre> <code class="bash hljs">zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test.zig <span class="hljs-string"><span class="hljs-string">"thing.zig"</span></span> 10L, 127C written :!zig <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> thing.zig Test 1/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> true...OK Test 2/2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> false...assertion failure [37;1m_panic.7 [0m: [2m0x0000000105260f34 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_panic [0m: [2m0x0000000105260d6b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_assert [0m: [2m0x0000000105260619 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_test <span class="hljs-literal"><span class="hljs-literal">false</span></span> [0m: [2m0x0000000105260cfb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main.0 [0m: [2m0x00000001052695ea <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMain [0m: [2m0x0000000105269379 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_callMainWithArgs [0m: [2m0x00000001052692f9 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m_main [0m: [2m0x0000000105269184 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x00007fff5c75c115 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m [37;1m??? [0m: [2m0x0000000000000001 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ??? (???) [0m</code> </pre> <br>  The test fell.  Use the following command to reproduce the error: <br><br><pre> <code class="plaintext hljs">./zig-cache/test</code> </pre> <br>  <a href="https://github.com/ziglang/zig/pull/780">Stack trace on poppy while in development.</a> <br><br>  To test it effectively, I need to break it apart.  Let's start with this: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: [30000]u8) void { var memptr: u16 = 0; for (src) |c| { switch(c) { '+' =&gt; mem[memptr] += 1, '-' =&gt; mem[memptr] -= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, else =&gt; {} } } } pub fn main() void { var mem = []u8{0} ** 30000; const src = "+++++"; bf(src, mem); }</code> </pre> <br>  It seems to be working, right? <br><br>  But‚Ä¶ <br><br><pre> <code class="plaintext hljs">/main.zig:1:29: error: type '[30000]u8' is not copyable; cannot pass by value</code> </pre> <br><blockquote>  This is described in <a href="https://github.com/ziglang/zig/issues/733">https://github.com/zig-lang/zig/issues/733</a> . </blockquote><br>  Zig is strict about this.  Complex types, and all objects that can be resized cannot be passed by value.  This makes stack allocation predictable and logical, and avoids unnecessary copying.  If you want to use the semantics of the transfer by value in your program, you can implement it yourself using your allocation strategy, but the language itself does not support this under normal circumstances. <br><br>  A natural way to circumvent this limitation is to pass a pointer instead of a value (passing by reference).  Zig uses a different strategy, slices.  A slice is a pointer with a length attached to it and with checking for falling into the borders.  The syntax in the function signature is: <br><br><pre> <code class="plaintext hljs">fn bf(src: []const u8, mem: []u8) void { ... }</code> </pre> <br>  and when calling a function it looks like this: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..mem.len]);</code> </pre> <br>  Note that I defined the upper bound simply by referring to the length of the array.  There is an abbreviated form of recording for such cases: <br><br><pre> <code class="plaintext hljs">bf(src, mem[0..]);</code> </pre> <br>  Now I can start writing tests that test the bf () function directly.  For the time being, I will add test functions to the end of the file <br><br><pre> <code class="plaintext hljs">test "+" { var mem = []u8{0}; const src = "+++"; bf(src, mem[0..]); assert(mem[0] == 3); }</code> </pre> <br>  I take a mem array from one byte and then check what should happen (a byte is incremented three times).  It works! <br><br><pre> <code class="plaintext hljs">Test 1/1 +...OK</code> </pre> <br>  "-" is checked in the same way: <br><br><pre> <code class="plaintext hljs">test "-" { var mem = []u8{0}; const src = "---"; bf(src, mem[0..]); assert(mem[0] == 253); }</code> </pre> <br>  Does not work!  When I try to subtract 1 from 0, I get ... <br><br><pre> <code class="bash hljs">Test 2/2 -...<span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> overflow</code> </pre> <br>  mem is an array of unsigned bytes, and subtracting 1 from 0 causes an overflow.  Again, Zig makes me explicitly declare what I want.  In this case, I do not have to worry about overflow, in fact, I want it to occur, since we are dealing with <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a> , in accordance with <a href="https://en.wikipedia.org/wiki/Brainfuck">the brainfuck specification</a> .  This means that the decrement of the cell with the number 0 will give me 255, and the increment of the value 255 will give me 0. <br><br>  Zig has several auxiliary arithmetic operations that offer <a href="https://ziglang.org/documentation/master/">guaranteed wrapping semantics</a> . <br><br><pre> <code class="plaintext hljs">'+' =&gt; mem[memptr] +%= 1, '-' =&gt; mem[memptr] -%= 1,</code> </pre> <br>  This solves the problem of overflowing the whole and does what I expected. <br><br>  To test &lt;and&gt;, I move through a small array and check the value of the incremented cell: <br><br><pre> <code class="plaintext hljs">test "&gt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++"; bf(src, mem[0..]); assert(mem[3] == 3); }</code> </pre> <br>  and‚Ä¶ <br><br><pre> <code class="plaintext hljs">test "&lt;" { var mem = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, mem[0..]); assert(mem[3] == 3); assert(mem[2] == 2); assert(mem[1] == 1); }</code> </pre> <br>  In the latter case, I can directly compare the result with a static array using ... <br><br><pre> <code class="plaintext hljs">const mem = std.mem;</code> </pre> <br>  Recall that I have already imported std.  In the example below, I use mem.eql in this namespace: <br><br><pre> <code class="plaintext hljs">test "&lt;" { var storage = []u8{0} ** 5; const src = "&gt;&gt;&gt;+++&lt;++&lt;+"; bf(src, storage[0..]); assert(mem.eql(u8, storage, []u8{ 0, 1, 2, 3, 0 })); }</code> </pre> <br>  ... and remember, string literals, these are just u8 arrays in zig, and I can put hexadecimal literals in them, i.e.  The following code will work the same way! <br><br><pre> <code class="plaintext hljs">assert(mem.eql(u8, storage, "\x00\x01\x02\x03\x00"));</code> </pre> <br>  Add "."!  It simply prints the value of a byte in the cell indicated by the pointer as a character.  Now I use warn, but later I will replace it with stdout.  This is simply conceptual, but somewhat confusing in implementation.  I will do it later! <br><br><pre> <code class="plaintext hljs">'.' =&gt; warn("{c}", storage[memptr]),</code> </pre> <br>  Cycles <br>  [and] - here the magic begins ... <br><br>  [- if the value of the current cell is zero, skip steps to the closing bracket without executing the code. <br>  ] - if the value of the current cell is not zero, go back to the opening bracket and execute the code again. <br><br>  This time I will start with the test, I will test them together (obviously, it does not make sense to test them separately).  The first test case - the storage [2] cell should be empty, although the loop should increment it if it starts: <br><br><pre> <code class="plaintext hljs">test "[] skips execution and exits" { var storage = []u8{0} ** 3; const src = "+++++&gt;[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 5); assert(storage[1] == 0); assert(storage[2] == 0); }</code> </pre> <br>  and I will create blanks for the switch statement: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { }, ']' =&gt; if (storage[memptr] == 0) { },</code> </pre> <br>  What to do now?  You can use a naive approach.  I just increment the src pointer until I find it].  But I cannot use for this a for loop in zig, it was created only for iterating over collections, without missing their elements.  The appropriate construction here is while: <br><br>  It was: <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; for (src) |c| { switch(c) { ... } }</code> </pre> <br>  it became ... <br><br><pre> <code class="plaintext hljs">var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { ... } srcptr += 1; }</code> </pre> <br>  Now I can reassign the srcptr pointer in the middle of the block, and I will: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { while (src[srcptr] != ']') srcptr += 1; },</code> </pre> <br>  This satisfies the test "[] skips code execution and exits" <br>  This satisfies the test ‚Äú[] skips execution and exits‚Äù, although not quite reliably, as we shall see. <br><br>  What about closing brackets?  I think you can write simply by analogy: <br><br><pre> <code class="plaintext hljs">test "[] executes and exits" { var storage = []u8{0} ** 2; const src = "+++++[&gt;+++++&lt;-]"; bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 25); } ']' =&gt; if (storage[memptr] != 0) { while (src[srcptr] != '[') srcptr -= 1; },</code> </pre> <br>  You can see what is happening ... A naive solution with two brackets has a fatal flaw and completely breaks down on nested loops.  Consider the following: <br><br><pre> <code class="plaintext hljs">++&gt;[&gt;++[-]++&lt;-]</code> </pre> <br>  The result should be {2, 0}, but the first open bracket just stupidly goes to the first closing bracket, and everything gets confused.  Jump to the next closing bracket at the same level of nesting.  It‚Äôs easy to add a depth counter and keep track of it as you move forward along the line.  We do it in both directions: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) { var depth:u16 = 1; srcptr += 1; while (depth &gt; 0) { srcptr += 1; switch(src[srcptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } }, ']' =&gt; if (storage[memptr] != 0) { var depth:u16 = 1; srcptr -= 1; while (depth &gt; 0) { srcptr -= 1; switch(src[srcptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } },</code> </pre> <br>  and relevant tests: note that src in both tests includes an internal loop. <br><br><pre> <code class="plaintext hljs">test "[] skips execution with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++&gt;[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 2); assert(storage[1] == 0); } test "[] executes with internal braces and exits" { var storage = []u8{0} ** 2; const src = "++[&gt;++[-]++&lt;-]"; try bf(src, storage[0..]); assert(storage[0] == 0); assert(storage[1] == 2); }</code> </pre> <br><blockquote>  Separately, we note, [-] - idiom brainfuck, meaning "reset this cell."  You can see that it doesn‚Äôt matter what value the cell had at the beginning, it will decrement until it reaches 0, and then execution will continue. </blockquote><br><h3>  Unlucky way </h3><br>  I did not count on the possibility that the program on bf would be broken.  What happens if I submit the wrong input program to my interpreter?  For example, simply [without a closing bracket, or &lt;, which immediately goes beyond the memory array?  (I can wrap the memory pointer, but it's better to treat it as an error). <br><br>  I'm going to look a bit ahead and explain all the differences in the code.  I will render the bf interpreter function into a separate file and also render the functionality of seekBack and seekForward into my own small functions. <br><br><pre> <code class="plaintext hljs">const warn = @import("std").debug.warn; const sub = @import("std").math.sub; fn seekBack(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr = sub(u16, ptr, 1) catch return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth -= 1, ']' =&gt; depth += 1, else =&gt; {} } } return ptr; } fn seekForward(src: []const u8, srcptr: u16) !u16 { var depth:u16 = 1; var ptr: u16 = srcptr; while (depth &gt; 0) { ptr += 1; if (ptr &gt;= src.len) return error.OutOfBounds; switch(src[ptr]) { '[' =&gt; depth += 1, ']' =&gt; depth -= 1, else =&gt; {} } } return ptr; } pub fn bf(src: []const u8, storage: []u8) !void { var memptr: u16 = 0; var srcptr: u16 = 0; while (srcptr &lt; src.len) { switch(src[srcptr]) { '+' =&gt; storage[memptr] +%= 1, '-' =&gt; storage[memptr] -%= 1, '&gt;' =&gt; memptr += 1, '&lt;' =&gt; memptr -= 1, '[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr), '.' =&gt; warn("{c}", storage[memptr]), else =&gt; {} } srcptr += 1; } }</code> </pre> <br>  This makes the switch much easier to read, in my opinion, seekForward and seekBack look and work very similarly, and I was tempted to refactor them into something smarter and more compact, but in the end, they do different things and handle errors also in different ways.  It is easier to copy and correct, and so it will be clearer.  Also, I will correct seekForward later, at some point, perhaps in a later post. <br><br>  I added a few important things!  Note that all three functions now return a type! .. This is a new syntax for what used to be type% T (error union).  This means that a function may return either some specific type or an error.  When I try to call such a function, I must either use try before calling a function that forwards an error up the call stack if an error occurs, or use catch: <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch {}</code> </pre> <br>  Where I handle errors in the catch block.  As written, catch can swallow any errors.  This is bad practice, but here Zig makes us do it explicitly.  If I catch an error in an empty block, I thereby affirm that either I do not think that an error can occur, or I do not need to process it.  In practice, this can be something like a TODO, and in fact it is also very easy to make it explicit! <br><br><pre> <code class="plaintext hljs">const x = functionCall() catch { @panic("TODO") }</code> </pre> <br>  Recall that such a case will never happen in a production code.  I notify the compiler that I know what I am doing.  If an error could occur, I would have to add error handling. <br><br>  So, what kind of errors should I return from seekBack or seekForward? <br><br>  In seekBack: <br><br><pre> <code class="plaintext hljs">ptr = sub(u16, ptr, 1) catch return error.OutOfBounds;</code> </pre> <br>  I replaced the decrement of the pointer to use the sub function from std lib, which throws an overflow error if overflow occurs.  I want to catch this error and return the error OutOfBounds instead, which I create here just by using it. <br><br><blockquote>  <i>Zig errors are basically an array of error codes that are generated by the compiler when you use error. Something is a Error.</i>  <i>They are guaranteed to be unique, and can be used as values ‚Äã‚Äãin a switch block.</i> </blockquote><br>  I want to use OutOfBounds here because, semantically, if the memory pointer becomes less than zero, I ask the runtime to go beyond the memory space that I have allocated. <br><br>  Similarly, in the seekForward function: <br><br><pre> <code class="plaintext hljs">if (ptr &gt;= src.len) return error.OutOfBounds;</code> </pre> <br>  In this case, if the pointer is larger than src.len, I catch the error here and return the same error. <br><br>  when calling: <br><br><pre> <code class="plaintext hljs">'[' =&gt; if (storage[memptr] == 0) srcptr = try seekForward(src, srcptr), ']' =&gt; if (storage[memptr] != 0) srcptr = try seekBack(src, srcptr),</code> </pre> <br>  I try to call these functions.  If they are called successfully, they are executed correctly, and try returns the srcptr value.  If they are unsuccessful, try stops the execution of the function and returns an error to the place where the whole bf function is called. <br><br>  The call can be from the main! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; // yes, hello const hello_world = "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;."; pub fn main() void { storage = []u8{0} ** 30000; bf(hello_world, storage[0..]) catch {}; }</code> </pre> <br>  I swallow this error here and should not do so, but note the important point, how easily zig can send errors up through the stack of calls.  It is not the responsibility of the calling function to check every error case, but the compiler causes it to call every function that can complete with an error with try.  This should always be done, even if errors are ignored! <br><br><blockquote>  <i>The new try / catch syntax eliminates a lot of spells like %% and% that people dislike so much.</i> </blockquote><br>  Now I have implemented 7 out of 8 characters of brainfuck, and this is enough to run a ‚Äúmeaningful‚Äù program. <br><br><h3>  "Meaningful" program </h3><br>  Here is the program: <br><br><pre> <code class="plaintext hljs">// –Ω–∞—à —Å—Ç–∞—Ä—ã–π –¥—Ä—É–≥, —Ä—è–¥ –§–∏–±–æ–Ω–∞—á—á–∏ const fib = "++++++++++++++++++++++++++++++++++++++++++++&gt;++++++++++++++++++++++++++++++++&gt;++++++++++++++++&gt;&gt;+&lt;&lt;[&gt;&gt;&gt;&gt;++++++++++&lt;&lt;[-&gt;+&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;&lt;]&gt;[&lt;+&gt;-]&gt;[-]&gt;&gt;&gt;++++++++++&lt;[-&gt;-[&gt;+&gt;&gt;]&gt;[+[-&lt;+&gt;]&gt;+&gt;&gt;]&lt;&lt;&lt;&lt;&lt;]&gt;[-]&gt;&gt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;[++++++++++++++++++++++++++++++++++++++++++++++++.[-]]&lt;&lt;&lt;++++++++++++++++++++++++++++++++++++++++++++++++.[-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;.&gt;.&gt;&gt;[&gt;&gt;+&lt;&lt;-]&gt;[&gt;+&lt;&lt;+&gt;-]&gt;[&lt;+&gt;-]&lt;&lt;&lt;-]&lt;&lt;++...";</code> </pre> <br>  Run ... <br><br><pre> <code class="plaintext hljs">pub fn main() void { storage = []u8{0} ** 30000; bf(fib, storage[0..]) catch {}; }</code> </pre> <br>  voila! <br><br><pre> <code class="plaintext hljs">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 121, 98, 219,</code> </pre> <br><blockquote>  <i>One memory comes back to me every time I think about the Fibonacci series ... I learned about it from PBS (Public Broadcasting Service, American non-profit television broadcasting service) in the 80s, and I always remember that.</i>  <i>I thought it would be forgotten, but <a href="https://www.youtube.com/watch%3Fv%3Dbv8O456bNa8%26feature%3Dyoutu.be%26t%3D3m46s">Youtube is a great thing</a> .</i> </blockquote><br><h3>  How can I improve this? </h3><br>  I already hinted at a few TODOs.  I should not have used stderr for output.  I want to use stdout. <br><br>  Every time I open the interpreter, I open the stream to stdout and type into it: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br>  What is going on here? –Ø –≤—ã–∑—ã–≤–∞—é io.getStdOut(), –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏ (–∏ —Å–Ω–æ–≤–∞ —è —è–≤–Ω—ã–º –æ–±—Ä–∞–∑–æ–º –≥–ª–æ—Ç–∞—é –≤–æ–∑–º–æ–∂–Ω—É—é –æ—à–∏–±–∫—É —Å –ø–æ–º–æ—â—å—é catch unreachable ‚Äî –µ—Å–ª–∏ —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∏—Ç –æ—à–∏–±–∫—É, –ø—Ä–æ–≥—Ä–∞–º–º–∞ —É–ø–∞–¥—ë—Ç!). –Ø –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –ø–æ—Ç–æ–∫, –±–µ—Ä—É —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω–µ–≥–æ, –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é –µ–≥–æ –∫–∞–∫ –≤—ã—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫, –≤ –∫–æ—Ç–æ—Ä—ã–π —è –º–æ–≥—É –ø–∏—Å–∞—Ç—å –≤—ã–∑–æ–≤–æ–º print. print –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É, –∫–∞–∫ –∏ warn, —Ç–∞–∫ —á—Ç–æ –∑–∞–º–µ–Ω–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞–ø—Ä—è–º—É—é. print —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫—É, –∏ —è –≥–ª–æ—Ç–∞—é —ç—Ç–∏ –æ—à–∏–±–∫–∏ —Ç–æ–∂–µ. <br><br> –í –ø—Ä–∞–≤–∏–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞–Ω–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ, —è –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω—è—Ç—å –≤–æ –≤–Ω–∏–º–∞–Ω–∏–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ –æ—à–∏–±–∫–∏ –æ—Ç–∫—Ä—ã—Ç–∏—è stdout, –∏ —Ç–∞–∫–∂–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø–æ–ø—ã—Ç–æ–∫ –∑–∞–ø–∏—Å–∏ –≤ stdout. Zig –¥–µ–ª–∞–µ—Ç –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç—ã–º –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —ç—Ç–∏—Ö –æ—à–∏–±–æ–∫ –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –≤—ã –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –≤—ã –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç–µ –∏—Ö. <br><br> –ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –µ—Å–ª–∏ —è —Ä–µ—à—É, —á—Ç–æ —è —Ö–æ—á—É –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –º–æ–π –ø—Ä–æ—Ç–æ—Ç–∏–ø –≤ —Ä–µ–ª–∏–∑? –ë—É–¥—É –ª–∏ —è —Å–∏–¥–µ—Ç—å —Å —á–∞—à–∫–æ–π –∫–æ—Ñ–µ –∏ –¥–µ–ª–∞—Ç—å –Ω–µ–±–ª–∞–≥–æ–¥–∞—Ä–Ω—É—é —Ä–∞–±–æ—Ç—É –ø–æ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫, –ø–æ–ª–∞–≥–∞—è—Å—å –Ω–∞ –¥–µ—Å—è—Ç–∏–ª–µ—Ç–∏—è –æ–ø—ã—Ç–∞ –∏ –∑–Ω–∞–Ω–∏—è, –ø–æ–∑–≤–æ–ª—è—é—â–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–∏—Ç—å –∫–∞–∂–¥—ã–π –≤–æ–∑–º–æ–∂–Ω—ã–π —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏ –∏ –∫–∞–∫ —è –º–æ–≥—É –µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å? –ê —á—Ç–æ, –µ—Å–ª–∏ —É –º–µ–Ω—è –Ω–µ—Ç –¥–µ—Å—è—Ç–∏–ª–µ—Ç–∏–π –æ–ø—ã—Ç–∞ –∏ –Ω–∞–Ω–∏–π? –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ, Zig —Å–¥–µ–ª–∞–µ—Ç —ç—Ç–æ! <br><br> –Ø —Ö–æ—á—É –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –º–æ—â–Ω—É—é —à—Ç—É–∫—É, –≤—ã–≤–æ–¥ –æ—à–∏–±–æ–∫! <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch unreachable; }</code> </pre> <br><br> –Ø –∑–Ω–∞—é, —á—Ç–æ bf –º–æ–∂–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç !void. –Ø –≥–ª–æ—Ç–∞—é —ç—Ç—É –æ—à–∏–±–∫—É –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –≤—ã–∑–æ–≤–∞, –≤ —Ñ—É–Ω–∫—Ü–∏–∏ main. –ö–æ–≥–¥–∞ —è –≥–æ—Ç–æ–≤ –ø—Ä–∏–Ω—è—Ç—å –º–æ—é —Å—É–¥—å–±—É –∏ –¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –≤–µ—â–∏, —è –º–æ–≥—É –ª–æ–≤–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω—ã–µ –æ—à–∏–±–∫–∏ —Ç–∞–∫: <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br> –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä —Ç–µ–ø–µ—Ä—å –º–æ–π –¥—Ä—É–≥! <br><br><pre> <code class="bash hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> switch shell returned 1</code> </pre> <br> –≠—Ç–∞ –æ—à–∏–±–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤–∞–º –∑–Ω–∞–∫–æ–º–∞, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –ø–æ–¥–Ω–∏–º–∞–ª–∞—Å—å –∏–∑ bf –∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π! –ù–æ –¥–∞–≤–∞–π—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏–º, —á—Ç–æ —è —Å–º–æ—Ç—Ä—é –Ω–∞ –æ—à–∏–±–∫–∏, –≥–µ–Ω–µ—Ä–∏—Ä—É—é—â–∏–µ—Å—è stdout, –∫–æ—Ç–æ—Ä—ã–µ —è –ø—Ä–æ–≥–ª–æ—Ç–∏–ª –≤ bf. –í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –≥–ª–æ—Ç–∞—Ç—å –∏—Ö, —è –¥–æ–ª–∂–µ–Ω –ø–æ–¥–Ω–∏–º–∞—Ç—å –∏—Ö –≤–≤–µ—Ä—Ö –ø–æ —Ü–µ–ø–æ—á–∫–µ, –∏—Å–ø–æ–ª—å–∑—É—è try. –í—Å–ø–æ–º–Ω–∏–º, –∏—Å–ø–æ–ª—å–∑—É—è –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏, –≥–µ–Ω–µ—Ä–∏—Ä—É—é—â–µ–π –æ—à–∏–±–∫–∏, –±–µ–∑ catch, –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º try, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–≤–µ—Ä—à–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ –æ—à–∏–±–∫–∏, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—è –≤—ã–∑—ã–≤–∞—é—â–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫—É –ª—é–±—ã—Ö –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã—Ö –æ—à–∏–±–æ–∫. <br><br> –ò—Ç–∞–∫, –≤–º–µ—Å—Ç–æ: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(io.getStdOut() catch unreachable)).stream); ... '.' =&gt; stdout.print("{c}", storage[memptr]) catch unreachable, ...</code> </pre> <br> –î–µ–ª–∞–µ–º: <br><br><pre> <code class="plaintext hljs">const io = std.io; ... pub fn bf(src: []const u8, storage: []u8) !void { const stdout = &amp;(io.FileOutStream.init(&amp;(try io.getStdOut())).stream); ... '.' =&gt; try stdout.print("{c}", storage[memptr]), ...</code> </pre> <br> –ö–æ–º–ø–∏–ª–∏—Ä—É–µ–º: <br><br><pre> <code class="plaintext hljs">const bf = @import("./bf.zig").bf; const warn = @import("std").debug.warn; const serpinsky = "++++++++[&gt;+&gt;++++&lt;&lt;-]&gt;++&gt;&gt;+&lt;[-[&gt;&gt;+&lt;&lt;-]+&gt;&gt;]&gt;+[ -&lt;&lt;&lt;[ -&gt;[+[-]+&gt;++&gt;&gt;&gt;-&lt;&lt;]&lt;[&lt;]&gt;&gt;++++++[&lt;&lt;+++++&gt;&gt;-]+&lt;&lt;++.[-]&lt;&lt; ]&gt;.&gt;+[&gt;&gt;]&gt;+ ] "; pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { }; }</code> </pre> <br> –∏ –ø–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–µ —è –º–æ–≥—É –ø–æ–ª—É—á–∏—Ç—å, –≤—ã–∑—ã–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—é! <br><br><pre> <code class="plaintext hljs">/Users/jfo/code/zigfuck/main.zig:7:46: error: error.SystemResources not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OperationAborted not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.IoPending not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.BrokenPipe not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.Unexpected not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.WouldBlock not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileClosed not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DestinationAddressRequired not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.DiskQuota not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.FileTooBig not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.InputOutput not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoSpaceLeft not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.AccessDenied not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.OutOfBounds not handled in switch /Users/jfo/code/zigfuck/main.zig:7:46: error: error.NoStdHandles not handled in switch shell returned 1</code> </pre> <br> Zig –¥–∞—ë—Ç –º–Ω–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —ç—Ç–∏ –æ—à–∏–±–∫–∏ —Ç—â–∞—Ç–µ–ª—å–Ω–æ, –µ—Å–ª–∏ —è —Ö–æ—á—É –∏–ª–∏ –º–æ–≥—É —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ! –Ø –¥–µ–ª–∞—é switch –ø–æ –∑–Ω–∞—á–µ–Ω–∏—è–º –æ—à–∏–±–∫–∏, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è —Å–ª—É—á–∞–∏, –µ—Å–ª–∏ —è —Ö–æ—á—É, –∏ –ø—Ä–æ–ø—É—Å–∫–∞—è, –µ—Å–ª–∏ —è —Ö–æ—á—É –∏—Ö –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å. <br><br><pre> <code class="plaintext hljs">pub fn main() void { var storage = []u8{0} ** 30000; bf(serpinsky, storage[0..]) catch |err| switch (err) { error.OutOfBounds =&gt; @panic("Out Of Bounds!"), else =&gt; @panic("IO error") }; }</code> </pre> <br> –≠—Ç–æ –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫, —Å—Ç—Ä–æ–≥–æ –≥–æ–≤–æ—Ä—è, –Ω–æ —è –ø—Ä–æ—Å—Ç–æ —Ö–æ—á—É –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å, –Ω–∞—Å–∫–æ–ª—å–∫–æ —É–º—ë–Ω Zig, —Å–æ–æ–±—â–∞—è –æ –≤—Å–µ–≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö –æ—à–∏–±–æ–∫ –≤ –≤—ã–∑—ã–≤–∞—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é! –ò –∫–æ–≥–¥–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –æ—à–∏–±–∫–∞, –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ <a href="https://ziglang.org/download/0.2.0/release-notes.html">—Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É –æ—à–∏–±–∫–∏</a> –≤–º–µ—Å—Ç–æ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ —Å—Ç–µ–∫–∞! –ö—Ä—É—Ç–∞—è –≤–µ—â—å! <br><br><h3> Todo </h3><br> –ï—Å—Ç—å –º–Ω–æ–≥–æ —Ä–∞–∑–Ω—ã—Ö —É–ª—É—á—à–µ–Ω–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä–æ–º! –ù—É–∂–Ω–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –¥–µ–ª–∞—Ç—å –æ–±—Ä–∞–±–æ—Ç–∫—É –≤—Å–µ—Ö –æ—à–∏–±–æ–∫, –æ—á–µ–≤–∏–¥–Ω–æ, –∏ –Ω—É–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –æ–ø–µ—Ä–∞—Ç–æ—Ä ",", –∫–æ—Ç–æ—Ä—ã–π –≤ brainfuck-–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç —Ä–æ–ª—å —Ñ—É–Ω–∫—Ü–∏–∏ getc, –ø–æ–∑–≤–æ–ª—è—è –≤–≤–æ–¥–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –ø—Ä–æ–≥—Ä–∞–º–º—É –ø—Ä–∏ –µ—ë –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏. –¢–∞–∫–∂–µ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —á—Ç–µ–Ω–∏—è –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ –±—É—Ñ–µ—Ä –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –µ–≥–æ, –≤–º–µ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∑–∞—Ö–∞—Ä–¥–∫–æ–∂–µ–Ω–Ω–æ–≥–æ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –∫–æ–¥–∞ bf. –¢–∞–∫–∂–µ –µ—Å—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —É–ª—É—á—à–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —è–≤–ª—è—é—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏, –Ω–æ –º–æ–≥—É—Ç –ø—Ä–æ–∏–ª–ª—é—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ Zig. –í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –≤—ã–≤–∞–ª–∏—Ç—å –∏—Ö –≤—Å–µ –≤ –∫–æ–Ω—Ü–µ –ø–æ—Å—Ç–∞, —è —Å–æ–±–∏—Ä–∞—é—Å—å —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∏—Ö –Ω–∞ —á–∞—Å—Ç–∏ –∏ –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –ø–æ—Å—Ç–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –±—É–¥—É—Ç –º–µ–Ω—å—à–µ –∏ –ø—Ä–æ—â–µ –≤ —É—Å–≤–æ–µ–Ω–∏–∏. <br><br><h3>  Conclusion </h3><br> –Ø –Ω–∞–¥–µ—é—Å—å, —á—Ç–æ —ç—Ç–æ—Ç –Ω–∞–ø–æ–ª–æ–≤–∏–Ω—É –∑–∞–∫–æ–Ω—á–µ–Ω–Ω—ã–π –º–∏–Ω–∏–∞—Ç—é—Ä–Ω—ã–π –ø—Ä–æ–µ–∫—Ç –¥–∞–ª –≤–∞–º –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ —Ç–æ–≥–æ, –Ω–∞ —á—Ç–æ –ø–æ—Ö–æ–∂ –∫–æ–¥ Zig –∏ –¥–ª—è —á–µ–≥–æ –æ–Ω –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω. Zig –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —à–≤–µ–π—Ü–∞—Ä—Å–∫–∏–º –Ω–æ–∂–æ–º, —ç—Ç–æ –Ω–µ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –≤—Å–µ–≥–æ –ø–æ–¥—Ä—è–¥, –æ–Ω —Å—Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞–Ω –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã—Ö –≤–µ—â–∞—Ö, –Ω–∞ —Ç–æ–º, —á—Ç–æ–±—ã –±—ã—Ç—å –ø—Ä–∞–≥–º–∞—Ç–∏—á–Ω—ã–º —Å–∏—Å—Ç–µ–º–Ω—ã–º —è–∑—ã–∫–æ–º, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω —Å–æ–≤–º–µ—Å—Ç–Ω–æ –∏–ª–∏ –≤–º–µ—Å—Ç–æ –° –∏ –°++. –≠—Ç–æ –∑–∞—Å—Ç–∞–≤–∏–ª–æ –º–µ–Ω—è —Ç—â–∞—Ç–µ–ª—å–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç—å –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –ø–∞–º—è—Ç–∏, —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–∞–º—è—Ç—å—é, –∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫. –í —Å—Ä–µ–¥–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º–∏ —Ä–µ—Å—É—Ä—Å–∞–º–∏, —ç—Ç–æ –ø–æ–ª–µ–∑–Ω–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ, –∞ –Ω–µ –±–∞–≥. Zig –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω, –Ω–µ –∏–º–µ–µ—Ç –¥–≤—É—Å–º—ã—Å–ª–µ–Ω–Ω–æ—Å—Ç–µ–π, –ø—ã—Ç–∞–µ—Ç—Å—è –æ–±–ª–µ–≥—á–∏—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏–µ –Ω–∞–¥—ë–∂–Ω–æ–≥–æ –∫–æ–¥–∞ –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏, –≤ –∫–æ—Ç–æ—Ä–æ–º —ç—Ç–æ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ —Å–ª–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å. <br><br> –Ø –æ–ø–∏—Å–∞–ª —Ç–æ–ª—å–∫–æ –º–∞–ª—É—é —á–∞—Å—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π Zig, –µ—Å—Ç—å –º–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π, –ø—Ä–∏—à–µ–¥—à–∏—Ö –≤ —è–∑—ã–∫ –≤ –≤–µ—Ä—Å–∏–∏ 0.2.0 –∏ –≤—ã—à–µ! –í–µ—Å—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π —è –Ω–∞–ø–∏—Å–∞–ª, —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω –≤ debug-—Ä–µ–∂–∏–º–µ, –∫–æ—Ç–æ—Ä—ã–π –æ–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è –ø—Ä–æ–≤–µ—Ä–æ–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –¥–ª—è —Å–æ–∫—Ä–∞—â–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏–∏ –±—ã—Å—Ç—Ä–µ–µ! –°—É—â–µ—Å—Ç–≤—É—é—Ç —Ä–µ–∂–∏–º—ã --release-fast –∏ --release-safe, –∏ –≤ –±—É–¥—É—â–µ–º –∏—Ö <a href="https://github.com/ziglang/zig/issues/531">–±—É–¥–µ—Ç –±–æ–ª—å—à–µ</a> . –ë–æ–ª—å—à–µ –ø—Ä–æ –∏—Ö —Ä–∞–∑–ª–∏—á–∏—è –∏ –æ–±—ä—è—Å–Ω–µ–Ω–∏—è –ø—Ä–æ —ç—Ç–∏ —Ä–µ–∂–∏–º—ã –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ—á–∏—Ç–∞—Ç—å <a href="https://andrewkelley.me/post/intro-to-zig.html">–∑–¥–µ—Å—å</a> . <br><br> –Ø –ø–æ—Å—Ç–æ—è–Ω–Ω–æ —É–¥–∏–≤–ª—è—é—Å—å —Å–∫–æ—Ä–æ—Å—Ç—å—é –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ Zig. –û—á–µ–Ω—å –º–Ω–æ–≥–æ–µ –ø–æ–∫–∞ –≤ –¥–≤–∏–∂–µ–Ω–∏–∏, –∏ –±—É–¥–µ—Ç —Ç–∞–∫–æ–≤—ã–º –¥–æ –≤—ã—Ö–æ–¥–∞ –≤–µ—Ä—Å–∏–∏ 1.0.0, –∏ –µ—Å–ª–∏ –≤—ã —Ä–µ—à–∏—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å Zig, –ø—Ä–æ—Å—Ç–æ –ø–æ–º–Ω–∏—Ç–µ –ø—Ä–æ —ç—Ç–æ, –µ—Å—Ç—å –º–Ω–æ–≥–æ —Ö–æ—Ä–æ—à–∏—Ö –∏–¥–µ–π, –∏ —è —Å –Ω–µ—Ç–µ—Ä–ø–µ–Ω–∏–µ–º –∂–¥—É –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏! <br><br> –ü–æ–ø—Ä–æ–±—É–π—Ç–µ, –∏ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ #zig –≤ freenode –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è, –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã. </div><p>Source: <a href="https://habr.com/ru/post/435574/">https://habr.com/ru/post/435574/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>