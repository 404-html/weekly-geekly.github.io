<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Review of the React quiz competition from the HeadHunter booth at HolyJs 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. September 24‚Äì25, HolyJs frontend developers conference https://holyjs-moscow.ru/ took place in Moscow. We came to the conference with our booth w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <div class="page-header-logo-container"></div>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Review of the React quiz competition from the HeadHunter booth at HolyJs 2018</h1><div class="post__text post__text-html js-mediator-article"><p>  Hey.  September 24‚Äì25, HolyJs frontend developers conference <a href="https://holyjs-moscow.ru/">https://holyjs-moscow.ru/</a> took place in Moscow.  We came to the conference with our booth where we spent quiz.  There was the main quiz - 4 qualifying rounds and 1 final, in which Apple Watch and Lego designers were raffled.  And separately, we held a quiz on knowledge. </p><br><p>  Under the cut - analysis of tasks quiz on react.  The correct options will be hidden under the spoiler, so you can not only read the analysis, but also check yourself :) </p><br><p><img src="https://habrastorage.org/webt/ot/wn/yq/otwnyqyymtf5t_yedi3aj2-wuau.jpeg" alt="image"></p><br><p>  Go! </p><a name="habracut"></a><br><p>  For convenience, we have grouped the questions into sections: </p><br><h3 id="sekciya-1-bazovoe-ponimanie-raboty-thissetstate-i-updating-lifecycle-komponenta">  Section 1. Basic understanding of how this.setState works and when updating the component lifecycle: </h3><br><p>  <strong>Question 1.</strong> </p><br><pre><code class="plaintext hljs">–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å–ø–æ—Å–æ–±–æ–≤ –æ–±–Ω–æ–≤–∏—Ç—å react-–∫–æ–º–ø–æ–Ω–µ–Ω—Ç: 1) SetProps, SetState, ForceUpdate 2) ForceUpdate, SetState 3) ForceUpdate, SetState, Parent (re)render 4) ForceUpdate, SetState, directly call UpdateComponent</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  3) ForceUpdate, SetState, Parent (re) render </p></div></div><br><p>  <strong>Question 2.</strong> </p><br><pre> <code class="plaintext hljs">–ß—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç, –µ—Å–ª–∏ –≤—ã–∑–≤–∞—Ç—å this.setState({}) –≤ react 1) –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –ø–æ–º–µ—Ç–∏—Ç—Å—è –≥—Ä—è–∑–Ω—ã–º, –≤—ã–∑–æ–≤–µ—Ç—Å—è updating lifecycle 2) –ù–∏—á–µ–≥–æ –Ω–µ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç, –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –æ–±–Ω–æ–≤–∏—Ç—Å—è 3) React —É–ø–∞–¥–µ—Ç —Å –æ—à–∏–±–∫–æ–π "Object cannot be empty" 4) –í—Å–µ –ø–æ–ª—è –≤ state –±—É–¥—É—Ç –∑–∞—Ä–µ—Å–µ—á–µ–Ω—ã</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  1) The component is marked dirty, updating lifecycle will be called </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Parsing questions 1 and 2</b> <div class="spoiler_text"><p>  To answer the question we will analyze 2 parts: <br>  1) Own component request for updating cycle <br>  2) Query outside the component </p><br><p>  The component itself has 2 ways to update itself: <br>  1) this.setState and this.forceUpdate.  In this case, the component will be marked dirty and on the Reconcilliation tick, if it is in priority for rendering, the updating cycle will start. </p><br><p>  Interesting fact: <code>this.setState({})</code> and <code>this.forceUpdate</code> are different.  When <code>this.setState({})</code> is called, the full updating cycle is called, unlike <code>this.forceUpdate</code> , when the updating cycle starts without the shouldComponentUpdate method.  An example of how <code>this.setState({})</code> works can be found here: <a href="https://codesandbox.io/s/m5jz2701l9">https://codesandbox.io/s/m5jz2701l9</a> (if you replace forceS in the example setState with forceUpdate, you can see how the behavior of the components will change). </p><br><p>  2) When the parent of the component is rendered, it returns the part of the vDOM, all the children that will have to be updated - and they will also have a full updating lifecycle.  A full translation of the subtree can be avoided by describing shouldComponentUpdate or by defining the component as PureComponent. </p></div></div><br><p>  <strong>Question 3</strong> </p><br><pre> <code class="plaintext hljs">–ß–µ–º –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è Component –æ—Ç PureComponent (PC) 1) Component –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ, –≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç Pure 2) PC —Ä–µ–∞–ª–∏–∑—É–µ—Ç SCU, –ø—Ä–æ–≤–æ–¥–∏—Ç shallowEqual props –∏ state 3) PC –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç store 4) –í PC –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Ñ—É–Ω–∫—Ü–∏—é shouldComponentUpdate</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  2) PC implements SCU, conducts shallowEqual props and state </p><br><p>  As we discussed earlier, when (re) rendering the parent, the entire subtree will be sent to the updating lifeCycle.  Imagine that you have updated the root element.  In this case, the chain effect you should be updated almost the entire react-tree.  In order to optimize and not send too much updating, there is a method <code>shouldComponentUpdate</code> , which allows to return true if the component should be updated, and false otherwise.  To simplify the comparison in react, you can inherit from <code>PureComponent</code> to get immediately ready <code>shouldComponentUpdate</code> , which compares by reference (if we are talking about object types) or by value (if we are talking about value types) all props and state that come into the component. </p></div></div><br><p>  <strong>Question 4.</strong> </p><br><pre> <code class="plaintext hljs">this.setState(() =&gt; {}, () =&gt; {}) ‚Äî –∑–∞—á–µ–º –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤—Ç–æ—Ä—É—é —Ñ—É–Ω–∫—Ü–∏—é –≤ setState? 1) set –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –Ω–∞–±–æ—Ä –æ–±—ä–µ–∫—Ç–æ–≤. –û–Ω–∏ —Å–º–µ—Ä–∂–∞—Ç—Å—è –ø–µ—Ä–µ–¥ updating 2) –í—Ç–æ—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–∞ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ state 3) setState –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ 1 –∞—Ä–≥—É–º–µ–Ω—Ç</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  2) The second function will be called after the state is updated. </p><br><p>  There are two methods in React-lifecycle: <code>componentDidMount</code> for the mounting loop and componentDidUpdate for updating, where you can add some logic after updating the component.  For example, make an http request, make some style changes, get the metrics of html elements and (by condition) make setState.  If you want to do some kind of action after changing certain fields in the state, then in the <code>componentDidUpdate</code> method you will have to write or compare: </p><br><pre> <code class="plaintext hljs">componentDidUpdate(prevProp, prevState) { if (prevState.foo !== this.state.foo) { // do awesome things here } }</code> </pre> <br><p>  Or you can do this by setState: </p><br><pre> <code class="plaintext hljs">setState( // set new foo {foo: 'baz'}, () =&gt; { // do awesome things here } );</code> </pre> <br><p>  Each approach has pros and cons (for example, if you change setState in several places, it may be more convenient to write a condition once). </p></div></div><br><p>  <strong>Question 5.</strong> </p><br><pre> <code class="plaintext hljs">–°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ –≤ –∫–æ–Ω—Å–æ–ª—å render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' onClick={() =&gt; console.log('foo')} /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  2) 2 </p></div></div><br><p>  <strong>Question 6.</strong> </p><br><pre> <code class="plaintext hljs">–°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ –≤ –∫–æ–Ω—Å–æ–ª—å render: class A extends React.PureComponent { render() { console.log('render'); return &lt;div /&gt; } } function Test() { return &lt;A foo='bar' /&gt; } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;Test /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;Test /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  eleven </p></div></div><br><p>  <strong>Question 7.</strong> </p><br><pre> <code class="plaintext hljs">–°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ –≤ –∫–æ–Ω—Å–æ–ª—å render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  eleven </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Analysis questions 5-7</b> <div class="spoiler_text"><p>  Questions 5‚Äì7 Needed for the same thing - to check the understanding of the operation of <code>PureComponent</code> and component updates during the transfer of props.  If inside the render method we pass in the form of a jsx callback, describing it directly in the render function: </p><br><pre> <code class="plaintext hljs">render () { return &lt;Button onClick={() =&gt; {}} /&gt;; }</code> </pre> <br><p>  Then each render parent will update this click handler.  This happens because with each render a new function is created with a unique link, which, when compared in PureComponent, will show that the new props are not equal to the old ones and the component needs to be updated.  In the case when all checks pass and shouldComponentUpdate returns false, the update does not occur. </p></div></div><br><h3 id="sekciya-2-keys-in-react">  Section 2. Keys in React </h3><br><p>  A detailed analysis of the work of the keys we published here: <a href="https://habr.com/company/hh/blog/352150/">https://habr.com/company/hh/blog/352150/</a> </p><br><p>  <strong>Question 1.</strong> </p><br><pre> <code class="plaintext hljs">–î–ª—è —á–µ–≥–æ –º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è key, –µ—Å–ª–∏ —Ä–∞–±–æ—Ç–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–µ —Å –º–∞—Å—Å–∏–≤–æ–º? 1) –£–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –∏–Ω—Å—Ç–∞–Ω—Å –∏ –∑–∞–º–∞—É–Ω—Ç–∏—Ç—å –Ω–æ–≤—ã–π –ø—Ä–∏ —Å–º–µ–Ω–µ key 2) –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–ø–æ—Å–æ–± –≤—ã–∑–≤–∞—Ç—å updating lifecycle 3) –ü—Ä–∏—á–∏–Ω –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å key –Ω–µ—Ç 4) –î–ª—è —Ñ–æ—Ä—Å–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ—Ö–∞–Ω–∏–∑–º–∞ reconciliation</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  1) Delete the previous instance and make a new one when changing the key </p><br><p>  Without using key reacts, it will compare the list of elements in pairs from top to bottom.  If we use key, the comparison will occur on the corresponding key.  If a new key appears, then such a component will not be compared with anyone and it will immediately be created from scratch. <br>  This method can be used even if we have 1 element: we can set <code>&lt;A key="1" /&gt;</code> , in the next render we specify <code>&lt;A key="2" /&gt;</code> and in this case, react will delete <code>&lt;A key="1" /&gt;</code> and create from scratch <code>&lt;A key="2" /&gt;</code> . </p></div></div><br><p>  <strong>Question 2.</strong> </p><br><pre> <code class="plaintext hljs">–ò–º–µ–µ—Ç –ª–∏ —Å–∞–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–æ—Å—Ç—É–ø –∫ this.prop.key? 1) –î–∞ 2) –ù–µ—Ç 3) –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å static getKey</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  2) No </p><br><p>  A component can learn the key from its children, which were given to it as a prop, but cannot find out about its key. </p></div></div><br><p>  <strong>Question 3.</strong> </p><br><pre> <code class="plaintext hljs">–°–∫–æ–ª—å–∫–æ —Ä–∞–∑ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ –≤ –∫–æ–Ω—Å–æ–ª—å render: class A extends React.PureComponent { componentDidMount() { console.log('render'); } render() { return &lt;div /&gt; } } const rootElement = document.getElementById("root"); ReactDOM.render(&lt;A key='1' /&gt;, rootElement); setTimeout(() =&gt; ReactDOM.render(&lt;A /&gt;, rootElement)); 1) 1 2) 2 3) 3 4) 0</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  2) 2 </p><br><p>  When the key is changed, the component will be recreated, so the render will be displayed twice. </p></div></div><br><h3 id="sekciya-3-voprosy-po-jsx">  Section 3. Questions on jsx </h3><br><p>  <strong>Question 1.</strong> </p><br><pre> <code class="plaintext hljs">–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ—Ç–≤–µ—Ç. –î–æ—á–µ—Ä–Ω–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –º–æ–∂–µ—Ç —É–≤–µ–¥–æ–º–∏—Ç—å —Å–≤–æ–µ–≥–æ —Ä–æ–¥–∏—Ç–µ–ª—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö —Å –ø–æ–º–æ—â—å—é 1) –ö–æ–ª–±–µ–∫–∞ –≤ –≤–∏–¥–µ prop / context 2) –í—ã–Ω–æ—Å–∞ —Å–ª–æ—è –º–æ–¥–µ–ª–∏ –∏ —Ä–∞–±–æ—Ç—ã —á–µ—Ä–µ–∑ –Ω–µ–µ 3) –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è setParentProps 4) –ß–µ—Ä–µ–∑ static getParentRef</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  1) Callback in the form of prop / context <br>  2) Take out the model layer and work through it </p><br><p>  There are two correct answers here.  The choice of any of them on the quiz will count you points.  This question is for knowledge of data-flow react.  Data from top to bottom is distributed in the form of props or context, there may be a callback, which the component below can call to affect the state of the system. <br>  Another way of combining the model take-off, context and prop, is, for example, react-redux binding. <br>  This library takes the model derived from the react (redux).  Setit redux.store in Provider, which actually sets store in context.  The developer then uses HOC connect, which goes into context, subscribes to the store (store.subscribe) changes, and when the store changes, it recalculates the <code>mapStateToProps</code> function.  If the data has changed, set it to props in the object being wrapped. <br>  At the same time, connect allows you to specify <code>mapDispatchToProps</code> , where the developer specifies the actionCreators to be transferred to the component.  We, in turn, receive them from the outside (without context), bind the <code>actionCreators</code> on the store (we wrap them in store.dispatch) and pass props to the wrapped component as props. </p></div></div><br><p>  <strong>Question 2.</strong> </p><br><pre> <code class="plaintext hljs">–í –∫–∞–∫–∏–µ props –º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å jsx? –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –æ—Ç–≤–µ—Ç 1) –í –ª—é–±—ã–µ 2) –¢–æ–ª—å–∫–æ –≤ children</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  1) In any </p><br><p>  You can transfer to any.  For example: </p><br><pre> <code class="plaintext hljs">&lt;Button icon={&lt;Icon kind='warning'/&gt;}&gt;–í–Ω–∏–º–∞–Ω–∏–µ&lt;/Button&gt;</code> </pre> <br><p>  Draws a button with an icon.  This approach is very convenient to use to leave the component the right to control the location of the various elements relative to each other, and not to touch one children prop. </p></div></div><br><h3 id="sekciya-4-prodvinutoe-ponimanie-setstate">  Section 4. Advanced understanding of setState </h3><br><p>  Here are 3 strongly related questions: </p><br><p>  <strong>Question 1.</strong> </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; ... this.setState({a: 'b'}); this.setState({a: this.state.a + 1}) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3) –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö 4) {a: 'a'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  3) Not enough data </p></div></div><br><p>  <strong>Question 2.</strong> </p><br><pre> <code class="plaintext hljs">this.state={a: 'a'} ... this.setState({a: 'b'}) this.setState(state =&gt; ({a: state.a + 1})) this.state? 1) {a: 'a1'} 2) {a: 'b1'} 3) –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö 4) {a: 'ab1'}</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  2) {a: 'b1'} </p></div></div><br><p>  <strong>Question 3.</strong> </p><br><pre> <code class="plaintext hljs">–ü—Ä–∏ –≤—ã–∑–æ–≤–µ –ø–æ–¥—Ä—è–¥ 2 setState –≤–Ω—É—Ç—Ä–∏ componentDidUpdate —Å–∫–æ–ª—å–∫–æ updating lifecycle –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–æ 1) 1 2) 2 3) 3 4) –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  eleven </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Debriefing 1-3</b> <div class="spoiler_text"><p>  All setState work is fully described here: <br>  1) <a href="https://reactjs.org/docs/react-component.html">https://reactjs.org/docs/react-component.html#setstate</a> <br>  2) <a href="https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973">https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973</a> </p><br><p>  The fact is that setState does not occur synchronously. <br>  And if there are several calls to setState in a row, then depending on whether we are inside the react-lifecycle method, the react-event handler function (onChange, onClick) or not, the execution of setState depends. <br>  Inside the react handlers, setState runs batch (changes are rolled only after the user functions in the call stack have run out and we‚Äôll fall into the functions that our event handler and lifecycle methods called).  They roll in a row one after another, so in case we are inside a react-handler, we get: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' + –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è. –ë—ã–ª–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –≤ —ç—Ç–æ–º this.state.a // a: 'a' this.setState({a: this.state.a + 1}) // a: 'a1'</code> </pre> <br><p>  since the changes occurred batchevo. <br>  But at the same time, if setState was called outside of the react-handlers: </p><br><pre> <code class="plaintext hljs">this.state = {a: 'a'}; // a: 'a' ... this.state.a // a: 'a' this.setState({a: 'b'}); // a: 'b' + –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —É—à–µ–ª –Ω–∞ —Ä–µ—Ä–µ–Ω–¥–µ—Ä this.state.a // a: 'b' this.setState({a: this.state.a + 1}) // a: 'b1' + –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —É—à–µ–ª –Ω–∞ —Ä–µ—Ä–µ–Ω–¥–µ—Ä</code> </pre> <br><p>  As in this case, the changes will roll separately. </p></div></div><br><h3 id="sekciya-5-redux">  Section 5. Redux </h3><br><p>  <strong>Question 1.</strong> </p><br><pre> <code class="plaintext hljs">–ú–æ–∂–Ω–æ –ª–∏ –∑–∞–¥–∞–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ action, –Ω–∞–ø—Ä–∏–º–µ—Ä () =&gt; {} ? 1) –ù–µ—Ç. –í—Å–µ action –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–±—ä–µ–∫—Ç–æ–º —Å –ø–æ–ª–µ–º type 2) –î–∞, –Ω–æ —Ç–∞–∫–æ–π action –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å –æ–±—ä–µ–∫—Ç —Å –ø–æ–ª–µ–º type 3) –î–∞, –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π middleware –¥–ª—è —Ç–∞–∫–æ–≥–æ action 4) –î–∞, –Ω–æ —Ç–∞–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –ø—Ä–∏–Ω–∏–º–∞—Ç—å –º–µ—Ç–æ–¥ dispatch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  3) Yes, you need to define custom middleware for such an action </p><br><p>  Take redux-thunk as the simplest example.  All middleware is a small block of code: <br>  <a href="">https://github.com/reduxjs/redux-thunk/blob/master/src/index.js#L2-L9</a> </p><br><pre> <code class="plaintext hljs">return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; { if (typeof action === 'function') { return action(dispatch, getState, extraArgument); } return next(action); };</code> </pre> <br><p>  How do middleware work? <br>  They get control before action comes to the store.  Therefore, the action, which was zadispachen, first pass through a chain of middleware. <br>  Each middleware accepts an instans store, the next method, which allows forwarding the action further, and the action itself. <br>  If the middleware handles custom action, such as redux-thunk, for example, if it is an action, it does not forward the action, but ‚Äúdrowns out‚Äù it, instead calling the action and passing the dispatch method and getState to it. <br>  What would happen if redux-thunk did next for action, which is a function? <br>  Before calling the store, the store checks the action type.  It must satisfy the following conditions: <br>  1) It must be an object. <br>  2) It should have a type field <br>  3) The type field must be of type string </p><br><p>  If one of the conditions is not met, redux will generate an error. </p></div></div><br><h3 id="bonusnye-voprosy">  Bonus questions: </h3><br><p>  <strong>Bonus Question 1.</strong> </p><br><pre> <code class="plaintext hljs">–ß—Ç–æ –±—É–¥–µ—Ç –≤—ã–≤–µ–¥–µ–Ω–æ? class Todos extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { return this.props.list.length - prevProps.list.length; } componentDidUpdate(a, b, c) { console.log(c); } ... } ReactDOM.render(&lt;Todos list={['a','b']} /&gt;, app); setTimeout(() =&gt; ReactDOM.render(&lt;Todos list={['a','b','a','b']} /&gt;, app), 0); a) 0 b) 1 c) 2 d) undefined</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer and analysis</b> <div class="spoiler_text"><p>  c) 2 </p><br><p>  <code>getSnapshotBeforeUpdate</code> is a rarely used function in react that allows you to get snapshots, which will then be passed to componentDidUpdate.  This method is needed to calculate in advance certain data, on the basis of which you can then make, for example, a fetch query. </p></div></div><br><p>  <strong>Bonus Question 2.</strong> </p><br><pre> <code class="plaintext hljs">–ß–µ–º—É –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∏–Ω–ø—É—Ç–µ —á–µ—Ä–µ–∑ 2,5 —Å–µ–∫—É–Ω–¥—ã? function Input() { const [text, setText] = useState("World!"); useEffect( () =&gt; { let id = setTimeout(() =&gt; { setText("Hello " + text); }, 1000); return () =&gt; { clearTimeout(id); }; }, [text] ); return ( &lt;input value={text} onChange={e =&gt; { setText(e.target.value); }} /&gt; ); } a) "World!" b) "Hello World!" c) "Hello Hello World!" d) –í –∫–æ–¥–µ –æ—à–∏–±–∫–∞</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text"><p>  c) "Hello Hello World!" </p></div></div><br><p>  This is a question about the knowledge of new features in the react, it was not in our quiz.  Let's try in the comments to describe in detail the work of the code from the last question :) </p></div><p>Source: <a href="https://habr.com/ru/post/431492/">https://habr.com/ru/post/431492/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>