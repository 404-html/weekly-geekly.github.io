<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Seamless client server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Any client-server project implies a clear separation of the code base into 2 parts (sometimes more) - client and server. Often, each such part is made...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Seamless client server</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/rq/-9/mh/rq-9mhais2g6p5dd5tsfv8rllak.jpeg" align="left">  Any client-server project implies a clear separation of the code base into 2 parts (sometimes more) - client and server.  Often, each such part is made out in the form of a separate independent project, supported by its team of developers. <br><br>  In this article, I propose to take a critical look at the standard rigid separation of code into backend and frontend.  And consider an alternative where in the code there is no clear line between the client and the server. <br><br><a name="habracut"></a><br><br><h3>  Cons of the standard approach </h3><br>  The main disadvantage of the standard division of the project into 2 parts is the blurring of business logic between the client and the server.  We edit the data in the form in the browser, verify it in the client code and send it to the village of the grandfather (to the server).  The server is another project.  There, too, you need to check the correctness of the incoming data (ie, duplicate the client's functionality), make some additional manipulations (save in the database, send an e-mail, etc.). <br><br>  Thus, in order to track the entire path of information from the form in the browser to the database on the server, we will have to dig into two diverse systems.  If the team has separate roles and different specialists are responsible for the backend and front-end, additional organizational problems arise due to their synchronization. <br><br><h3>  Let's dream </h3><br>  Suppose that we can describe the entire data path from the form on the client to the database on the server in one model.  In code, it might look something like this (code is not working): <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDataModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// –º–µ—Ç–æ–¥ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π –∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–µ verifyData(data) { // –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö .... return true; } // –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ –ø—Ä–∏ —Å–∞–±–º–∏—Ç–µ —Ñ–æ—Ä–º—ã client saveData(data) { if(this.verifyData(data)) this.writeDataToDb(data) else consol.log('error') } // —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –º–µ—Ç–æ–¥. –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ë–î server writeDataToDb(data) { if(this.verifyData(data)) this.db.insert(data) else consol.log('error') } }</span></span></code> </pre> <br>  Thus, the entire business logic of the model is before our eyes.  Maintain this code easier.  Here are the advantages that the combination of client-server methods in one model can bring: <br><br><ol><li>  Business logic is concentrated in one place, there is no need to separate it between the client and the server. </li><li>  You can easily transfer functionality from server to client or from client to server during project development. </li><li>  There is no need to duplicate the same methods for the backend and the frontend. </li><li>  A single set of tests for the entire business logic of the project. </li><li>  Replacing horizontal lines of responsibility in the project on the vertical. </li></ol><br>  The last item will reveal more.  Imagine a regular client-server application in the form of such a scheme: <br><br><img src="https://habrastorage.org/webt/8x/c9/de/8xc9degimzw-w-ln5w2ihiybi6w.jpeg" width="400"><br><br>  Vasya is responsible for the frontend, Fedya for the backend.  The line of responsibility is held horizontally.  This scheme has the disadvantages of any vertical structure - it is difficult to scale and has low fault tolerance.  If the project expands, you will have to make quite a difficult choice: who will Vasya or Fedya strengthen?  Or if Fedya fell ill or quit, Vasya could not replace him. <br><br>  The approach proposed here allows you to expand the line of responsibility demarcation by 90 degrees and turn the vertical architecture into a horizontal one. <br><br><img src="https://habrastorage.org/webt/v6/4m/9f/v64m9fuv5sonujosvh4yc4v8vbw.jpeg" width="400"><br><br>  Such architecture is much easier to scale and more fault tolerant.  Vasya and Fedya become interchangeable. <br><br>  In theory, it looks good, we will try to implement all this in practice, without losing on the road everything that gives us the separate existence of the client and server. <br><br><h3>  Formulation of the problem </h3><br>  We do not necessarily have to have an integrated client-server in production.  On the contrary, such a decision would be extremely harmful from all points of view.  The task is that in the development process we would have a single code base for data models for the backend and frontend, but the output would be an independent client and server.  In this case, we will get all the advantages of the standard approach and gain convenience in the development and support of the project listed above. <br><br><h3>  Decision </h3><br>  I have been experimenting with the integration of client and server in a single file for quite some time.  Until recently, the main problem was that in standard JS the connection of third-party modules on the client and the server was too different: require (...) in node.js, on the client any AJAX-magic.  Everything has changed with the advent of ES-modules.  In modern browsers, "import" has been supported for a long time.  Node.js lags behind a bit in this respect and ES modules are supported only with the "--experimental-modules" flag enabled.  It is hoped that in the foreseeable future, the modules will work out of the box and in node.js.  In addition, it is unlikely that much will change, because  In browsers, this functionality has long been the default.  I think that now you can use ES modules not only on the client but also on the server side (if you have counter arguments on this subject, write in the comments). <br><br>  The solution scheme looks like this: <br><br><img src="https://habrastorage.org/webt/xo/_a/vi/xo_avikvz1udp9-dwhxfe6ypt-q.png" width="600"><br><br>  The project contains three main catalogs: <br><br>  <b>protected</b> - backend; <br>  <b>public</b> - frontend; <br>  <b>shared</b> - common client-server models. <br><br>  A separate observer process monitors files in the shared directory and, with any changes, creates versions of the modified file separately for the client and separately for the server (in the protected / shared and public / shared directories). <br><br><h3>  Implementation </h3><br>  Consider the example of a simple real-time messenger.  We need a fresh node.js (I have version 11.0.0) and Redis (their installation is not considered here). <br><br>  Clone an example: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/both-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./both-example npm i</code> </pre><br>  Install and run the process-observer (observer on the diagram): <br><br><pre> <code class="bash hljs">npm i both-js -g both ./index.mjs</code> </pre><br>  If everything is in order, the observer will start the web server and start monitoring changes to files in the shared and protected directories.  At changes in shared the corresponding versions of data models for the client and for the server are created.  When changes to a protected observer will automatically restart the web server. <br><br>  You can see the performance of the messenger in the browser by clicking on the link <br><br> <code>http://localhost:3000/index.html?token=123&amp;user=Vasya</code> <br> <br>  (token and user arbitrary).  To emulate multiple users, open the same page in another browser specifying other token and user. <br><br>  Now for some code. <br><br><h4>  Web server </h4><br>  protected / server.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// –≤–µ–±-—Å–æ–∫–µ—Ç—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞ // –¥–ª—è –∫–ª–∏–µ–Ω—Ç-—Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è import wsServer from './lib/wsServer.mjs'; const app = express(); // –∑–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–µ—Ä –≤–µ–±-—Å–æ–∫–µ—Ç–æ–≤ wsServer(app); // –¥–æ–±–∞–≤–∏–º mime –¥–ª—è mjs express.static.mime.define({'application/javascript': ['js','mjs']}); app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); // —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –æ—Ç–¥–∞–µ–º –∏–∑ –∫–∞—Ç–∞–ª–æ–≥–∞ public app.use(express.static('public')); const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  This is an ordinary express-server, there is nothing interesting here.  The mjs extension is needed for ES modules in node.js.  For consistency, we will use this extension for the client. <br><br><h4>  Customer </h4><br>  public / index.html <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/main.mjs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user in users"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ user.name }} ({{user.id}}) <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messages"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sendMessage()"</span></span></span><span class="hljs-tag">&gt;</span></span>–û—Ç–ø—Ä–∞–≤–∏—Ç—å<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message in messages"</span></span></span><span class="hljs-tag">&gt;</span></span>[{{ message.date }}] <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>{{ message.text }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  For example, I use on the client Vue, but essentially it does not change.  Instead of Vue there can be anything where you can separate the data model into a separate class (knockout, angular). <br><br>  public / main.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–µ–±-—Å–æ–∫–µ—Ç–æ–º import ws from "/lib/Ws.mjs"; // –º–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ import Messages from "./shared/messages/model/dataModel.mjs"; // –º–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π import Users from "./shared/users/model/dataModel.mjs"; // –ø–æ–¥–∫–ª—é—á–∞–µ–º –≤–µ–±-—Å–æ–∫–µ—Ç (–Ω–∞ –ø—Ä–æ–µ–∫—Ç –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–¥–Ω–æ–≥–æ –∫–æ–Ω–Ω–µ–∫—Ç–∞) window.WS = new ws({ token: new URLSearchParams(document.location.search).get("token"), user: new URLSearchParams(document.location.search).get("user") }); // —Å–≤—è–∑—ã–≤–∞–µ–º –º–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —Å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º new Messages({ el: '#messages' }) // —Å–≤—è–∑—ã–≤–∞–µ–º –º–æ–¥–µ–ª—å –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º new Users({ el: '#users' })</span></span></code> </pre><br>  main.mjs is a script that associates data models with corresponding views.  To simplify the code of the sample view for the list of active users and message feeds are built right into index.html <br><br><h4>  Data model </h4><br>  shared / messages / model / dataModel.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å // –±–∞–∑–æ–≤—ã–µ –∫–ª–∞—Å—Å—ã –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π –∏ —Å–µ—Ä–≤–µ—Ä–Ω–æ–π —á–∞—Å—Ç–µ–π —Å–æ–¥–µ—Ä–∂–∞—Ç —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã, // –Ω–æ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ import Base from '@root/lib/Base.mjs'; export default class dataModel extends Base { //!#client constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); // –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#client async sendMessage(e) { //–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä await this.$sendMessage(this.msg); this.msg = ''; } //!#server async $sendMessage(text) { // –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ newmessage –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  These several methods implement all the functionality of sending and receiving messages in real time.  The! #Client and! #Server directives indicate to the monitoring process which method for which part (client or server) is intended.  If before the definition of the method there are no these directives, this method is available both on the client and on the server.  Comment slashes before the directive are not required and exist only so that the standard IDE does not swear for syntax errors. <br><br>  The first line in the path uses the substitution &amp; root.  When generating the client and server versions, &amp; root will be replaced with a relative path to the public and protected directories, respectively. <br><br>  Another important point: from the client method, you can call only the server method, the name of which starts with "$": <br><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">//–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä async sendMessage(e) { await this.$sendMessage(this.msg); &lt;- –≤—ã–∑—ã–≤–∞–µ–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–π –º–µ—Ç–æ–¥ this.msg = ''; } ...</span></span></code> </pre><br>  This is done for security reasons: from the outside you can only apply to specially-designed methods. <br><br>  Let's look at the versions of the data models that the observer (observer) generated for the client and server. <br><br>  <b>Client</b> (public / shared / messages / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} <span class="hljs-comment"><span class="hljs-comment">// constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); // –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } // async sendMessage(e) { //–æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä await this.$sendMessage(this.msg); this.msg = ''; } // ... async $sendMessage() {return await this.__runSharedFunction("$sendMessage",arguments)} }</span></span></code> </pre><br>  On the client side, the model is a descendant of the Vue class (via Base.mjs).  Thus, you can work with it as with the usual Vue data model.  The observer added the __getFilePath__ method to the client version of the model, which returns the path to the class file and replaced the $ sendMessage server method code with a construct that, in essence, through the rpc mechanism will call the required method on the server (__runSharedFunction is defined in the parent class). <br><br>  <b>Server</b> (protected / shared / messages / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} ... –∫—É—á–∞ –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ –≤–º–µ—Å—Ç–æ –∫–ª–∏–µ–Ω—Ç—Å–∫–∏—Ö –º–µ—Ç–æ–¥–æ–≤ ... <span class="hljs-comment"><span class="hljs-comment">// async $sendMessage(text) { // –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–æ–±—ã—Ç–∏–µ newmessage –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  The server version also added the __getFilePath__ method and removed client methods marked with the directive! #Client <br><br>  In both model generated versions, all deleted lines are replaced with empty ones.  This is done so that the debugger error message can easily find the problematic line in the model source code. <br><br><h4>  Client and server interaction </h4><br>  When we need to call a server method on the client, we just do it. <br>  If the challenge is within one model, everything is simple: <br><br><pre> <code class="javascript hljs">... !#client <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> sendMessage(e) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg = <span class="hljs-string"><span class="hljs-string">''</span></span>; } !#server <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $sendMessage(msg) { <span class="hljs-comment"><span class="hljs-comment">// —á—Ç–æ-—Ç–æ –¥–µ–ª–∞–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ } ...</span></span></code> </pre><br>  You can "pull" another model: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"/shared/messages/model/dataModel.mjs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dataModel(); msg.$sendMessage(<span class="hljs-string"><span class="hljs-string">'blah-blah-blah'</span></span>);</code> </pre><br>  In the opposite direction, i.e.  call on the server any client method does not work.  Technically, this is feasible, but from a practical point of view, it makes no sense, because  There is one server and many clients.  If we need to initiate some actions on the server on the client, we use the event mechanism: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å ... //!#client constructor(attr) { .... // –Ω–∞ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–π —Å—Ç–æ—Ä–æ–Ω–µ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ "newmessage" this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#server async $sendMessage(text) { // –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —Å–æ–±—ã—Ç–∏–µ newmessage –¥–ª—è –≤—Å–µ—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } ...</span></span></code> </pre><br>  The fireEvent method takes 3 parameters: the name of the event, to whom it is addressed and the data.  The addressee can be defined in several ways: ‚Äúall‚Äù keyword - the event will be sent to all users or in the array to list session tokens of those clients to whom the event is addressed. <br><br>  The event is not tied to a specific instance of the data model class and will trigger handlers in all instances of the class in which fireEvent was called. <br><br><h4>  Horizontal scaling backend </h4><br>  The solidity of client-server models in the proposed implementation, at first glance, should impose significant restrictions on the possibility of horizontal scaling of the server part.  But this is not the case: technically, the server does not depend on the client.  You can copy the ‚Äúpublic‚Äù directory anywhere and share its contents through any other web server (nginx, apache, etc.). <br><br>  The server part can be easily expanded by launching new instances of the backend.  Redis and the Kue queue system are used to communicate the individual instances. <br><br><h4>  API and different clients to the same backend </h4><br>  In real projects, diversified clients - web sites, mobile applications, third-party services can use one server API.  In the proposed solution, all this is available without any additional dances.  Under the hood of calling server methods is the good old rpc.  The web server itself is a classic express application.  It is enough to add a wrapper for routes with calling the necessary methods of the same data models. <br><br><h4>  Post scriptum </h4><br>  The approach proposed in the article does not pretend to any revolutionary changes in client-server applications.  He only adds a bit of comfort to the development process, allowing him to focus on the business logic gathered in one place. <br><br>  This project is experimental, write in the comments if you think it is worth continuing this experiment. </div><p>Source: <a href="https://habr.com/ru/post/435494/">https://habr.com/ru/post/435494/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>