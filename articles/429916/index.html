<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to build and build</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prehistory 


 Having met in numerous Javascript development sites with situations where it was necessary to validate the values, it became clear that...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>How to build and build</h1><div class="post__text post__text-html js-mediator-article"><h2 id="predystoriya">  Prehistory </h2><br><p>  Having met in numerous Javascript development sites with situations where it was necessary to validate the values, it became clear that it was necessary to somehow resolve this issue.  For this purpose, the following task was set: <br>  Develop a library that will enable: </p><br><ul><li>  validate <strong>data types</strong> ; </li><li>  set <strong>default values</strong> instead of invalid fields or elements; </li><li>  <strong>delete non-valid parts of an</strong> object or array; </li><li>  receive <strong>an error message</strong> ; </li></ul><br><p>  The basis of which will be: </p><br><ul><li>  Easy to learn </li><li>  Readability of the received code. </li><li>  Easy code modification </li></ul><br><p>  To achieve these goals, the <a href="https://www.npmjs.com/package/quartet" title="quartet">quartet</a> validation library was developed. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Basic validation bricks </h2><br><p>  Most of the systems that are calculated to be applicable in a wide range of tasks are based on the simplest <strong>elements</strong> : actions, data, and algorithms.  As well as the methods of their <strong>composition</strong> - with the goal of the simplest elements to collect something more difficult to solve more complex problems. </p><br><h3 id="validator">  Validator </h3><br><p>  The quartet library is based on the notion of a <strong>validator</strong> .  Validators in this library are the following functions </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  There are several things in this definition that are worth describing in more detail: </p><br><p>  <strong><code>function(...): boolean</code></strong> - says that the validator - calculates the result of validation, and the result of validation is a boolean value - <strong>true</strong> or <strong>false</strong> , respectively, <strong>valid</strong> or <strong>not valid</strong> </p><br><p>  <strong><code>value: any</code></strong> - says that the validator - calculates the result of validating the <strong>value</strong> , which can be any javascript value.  The validator either refers this <strong>validated value</strong> to valid or non-valid. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - indicates that the validated value may be in different contexts depending on what level of nesting the value is located at.  Let's show it in examples. </p><br><p>  Example value <strong>without any context</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">// –≠—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –¥—Ä—É–≥–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö. // –ß—Ç–æ–±—ã –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –µ–≥–æ –ø—Ä–æ–≤–∞–ª–∏–¥–∏—Ä–æ–≤–∞–ª –æ–Ω –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –Ω–∞ —Å–∞–º–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏: const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Example value <b>in array context</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –∫–ª—é—á–∏ 0 1 2 3 4 const arr = [1, 2, 3, value, 5] // –í –º–∞—Å—Å–∏–≤–µ –¥–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–¥ –∏–Ω–¥–µ–∫—Å–æ–º(k–µ—É): 3 // –†–æ–¥–∏—Ç–µ–ª–µ–º –≤ –¥–∞–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤: [1, 2, 3, value, 5] // –ü–æ—ç—Ç–æ–º—É –ø—Ä–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ value - –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å —Ç–∞–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Sample Value <b>in Object Context</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">// –í –¥–∞–Ω–Ω–æ–º –æ–±—å–µ–∫—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–µ—Ç –∫–ª—é—á —Ä–∞–≤–Ω—ã–π 'c' // –†–æ–¥–∏—Ç–µ–ª–µ–º –≤ –¥–∞–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —è–≤–ª—è–µ—Ç—Å—è –≤–µ—Å—å –æ–±—ä–µ–∫—Ç: { a: 1, b: 2, c: 4, d: 8 } // –ü–æ—ç—Ç–æ–º—É –ø—Ä–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ value - –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è // —Å —Ç–∞–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  Since the structures in the object can have more nesting, it makes sense to talk about a <b>variety of contexts</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] // –í –¥–∞–Ω–Ω–æ–º c–ª—É—á–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–º–µ–µ—Ç –∫–ª—é—á —Ä–∞–≤–Ω—ã–π 'c' // –ü–µ—Ä–≤—ã–º —Ä–æ–¥–∏—Ç–µ–ª–µ–º —è–≤–ª—è–µ—Ç—Å—è –æ–±—ä–µ–∫—Ç: { a: 1, b: 2, c: 4, d: 8 } // –í —Å–≤–æ—é –æ—á–µ—Ä–µ–¥—å —Ä–æ–¥–∏—Ç–µ–ª–µ–º —Ä–æ–¥–∏—Ç–µ–ª—è —è–≤–ª—è–µ—Ç—Å—è –º–∞—Å—Å–∏–≤ arrOfObj, // –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–±—ä–µ–∫—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–¥ –∏–Ω–¥–µ–∫—Å–æ–º 0. // –ü–æ—ç—Ç–æ–º—É –ø—Ä–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ value - –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å —Ç–∞–∫–∏–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  And so on. </p><br><div class="spoiler">  <b class="spoiler_title">On the similarity with array methods</b> <div class="spoiler_text"><p>  This definition of a validator should remind you of the definition of functions that are passed as an argument to the methods of arrays, such as: <strong>map, filter, some, every</strong> and so on. </p><br><ul><li>  The first argument of these functions is <strong>the array element.</strong> </li><li>  The second argument is <strong>the element index.</strong> </li><li>  The third argument is <strong>the array itself.</strong> </li></ul><br><p>  In this case, the validator is a more generalized function ‚Äî it accepts not only the index of the element in the array and the array, but also the index of the array ‚Äî in its parent and its parent, and so on. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  What should we build a house? </h3><br><p>  The bricks described above do not stand out in the midst of other <em>‚Äúsolution-stones‚Äù</em> , which are lying on the javascript crutch <em>‚Äúbeach‚Äù</em> .  So let's build something more slender and interesting out of them.  For this we have a <strong>composition</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  How to build a skyscraper object validation? </h3><br><p>  Agree, it would be convenient to validate objects in such a way that the description of the validation itself coincides with the description of the object.  For this we will use the <strong>object composition validators</strong> .  It looks like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –≤–∞–ª–∏–¥–∞—Ü–∏–∏ quartet const quartet = require('quartet') // –°–æ–∑–¥–∞—ë–º –∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ (v - –∑–Ω–∞—á–∏—Ç validator) const v = quartet() // –û–ø–∏—à–µ–º —Å—Ö–µ–º—É –æ–±—ä–µ–∫—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤, // –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –ø–æ–ª–µ–π const objectSchema = { a: a =&gt; typeof a ==='string', // –í–∞–ª–∏–¥–∞—Ç–æ—Ä —Ç–∏–ø–∞ 'string' b: b =&gt; typeof b === 'number', // –í–∞–ª–∏–¥–∞—Ç–æ—Ä —Ç–∏–ø–∞ 'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  As you can see, from different validator bricks defined for specific fields, we can assemble an object validator - some "small building", in which it is still quite tight - but better than without it.  For this we use validator composer <code>v</code> .  <strong>Whenever it encounters an object literal <code>v</code> at the place of a validator, it will consider it as an object composition, turning it into a validator of an object in its fields.</strong> </p><br><p>  Sometimes we <strong>cannot describe all the fields</strong> .  For example, when an object is a data dictionary: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  How to reuse construction solutions? </h3><br><p>  As we saw above, there is a need to reuse simple validators.  In these examples, we already had to use the "string type validator" two times already. </p><br><p>  In order to shorten the record and increase its readability in the quartet library, string synonyms of validators are used.  <strong>Whenever the composer of validators encounters a line at the place where the validator should be, he searches the dictionary for the corresponding validator and uses it</strong> . </p><br><p>  By default, the most common validators are already defined in the library. </p><br><p>  Consider examples: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  and many others described in the <strong><a href="https://github.com/whiteand/quartet" title="documentation">documentation</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Does each arch have its own kind of bricks? </h3><br><p>  The validator composer (function <code>v</code> ) is also a factory of validators.  In the sense that it contains many useful methods that return </p><br><ul><li>  validator functions </li><li>  values ‚Äã‚Äãthat will be perceived by the composer as schemes for creating validators </li></ul><br><p>  For example, let's look at the validation of an array: most often it consists of checking the type of the array and checking all its elements.  Use the <code>v.arrayOf(elementValidator)</code> method for this.  For example, take an array of points with names. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Since an array of points is an array of objects, it makes sense to use object composition to validate the elements of the array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number - –æ–¥–∏–Ω –∏–∑ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ y: 'number', name: 'string' // string - –æ–¥–∏–Ω –∏–∑ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ }</span></span></code> </pre> <br><p>  Now, using the factory method <code>v.arrayOf</code> , create a validator of the entire array. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Let's see how this validator works: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  This is just one of the factory methods, each of which is described in the <a href="https://github.com/whiteand/quartet" title="documentation">documentation.</a> </p><br><p>  As you saw above, <code>v.rest</code> also a factory method that returns an object composition that checks all fields not listed in the object composition.  So, it can be embedded into another object composition using a <code>spread-operator</code> . </p><br><p>  Here is an example of using several of them: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –≤–∞–ª–∏–¥–∞—Ü–∏–∏ quartet const quartet = require('quartet') // –°–æ–∑–¥–∞—ë–º –∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤ (v - –∑–Ω–∞—á–∏—Ç validator) const v = quartet() // –†–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ç–∞–∫–æ–π –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ–ø–∏—Å—ã–≤–∞–µ—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } // –∏–º—è –≤–∞–ª–∏–¥–Ω–æ, –∫–æ–≥–¥–∞ —è–≤–ª—è–µ—Ç—Å—è "–∏" —Å—Ç—Ä–æ–∫–æ–π, // "–∏" –Ω–µ –ø—É—Å—Ç–æ–π, "–∏" –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ - –±–æ–ª—å—à–∞—è const nameSchema = v.and( 'not-empty', 'string', // –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã name =&gt; name[0].toUpperCase() === name[0] // –≤–∞–ª–∏–¥–∞—Ç–æ—Ä-—Ñ—É–Ω–∫—Ü–∏—è ) const maxSchema = { name: nameSchema, // –í–∞–ª–∏–¥–∞—Ç–æ—Ä –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫ –∑–∞–¥–¥–∞–Ω–Ω–æ–º—É –º–Ω–æ–∂–µ—Å—Ç–≤—É –∑–Ω–∞—á–µ–Ω–∏–π sex: v.enum('male', 'female'), // –í–æ–∑—Ä–∞—Å—Ç - –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ. // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–º–µ–Ω–Ω–æ–≤–∞–Ω—ã–µ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä—ã –∏ —Ñ–∞–±—Ä–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ "–∏" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, // –≤–∞–ª–∏–¥–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –ø–æ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–º—É –≤—ã—Ä–∞–∂–µ–Ω–∏—é friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  To be or not to be? </h3><br><p>  It often happens that valid data takes various forms, for example: </p><br><ul><li>  <code>id</code> can be a number, or it can be a string. </li><li>  The <code>point</code> object may or may not contain some coordinates, depending on the dimension. </li><li>  And many other cases. </li></ul><br><p>  For the organization of the validation of options, a separate type of composition is provided - a variant composition.  It is represented by an array of validators of possible options.  An object is considered valid when at least one of the validators reported its validity. </p><br><p>  Consider an example with validation of identifiers: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">// –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ –Ω–µ–ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π v.and('positive', 'safe-integer') // –õ–∏–±–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Example with validation points: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">// –¥–ª—è –ø–µ—Ä–≤–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ - –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ç–æ–ª—å–∫–æ x –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ dimension: v.enum(1), x: 'number', // v.rest —Å —Ñ—É–Ω–∫—Ü–∏–µ–π –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π false // –û–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è - –Ω–µ–≤–∞–ª–∏–¥–Ω—ã ...v.rest(() =&gt; false) }, // –¥–ª—è –≤—Ç–æ—Ä–æ–π - —Ö –∏ —É { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, // –î–ª—è —Ç—Ä–µ—Ç—å–µ–π - x, y –∏ z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // –ò—Ç–æ–≥–æ, –≤–∞–ª–∏–¥–Ω–æ–π —Ç–æ—á–∫–æ–π —Å—á–∏—Ç–∞–µ—Ç—Å—è —Ç–∞, —É –∫–æ—Ç–æ—Ä–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –Ω–µ –≤—ã—à–µ —Ç—Ä–µ—Ç—å–µ–π, –∏ –¥–ª—è –∫–∞–∂–¥–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ - —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ –∫–æ–ª-–≤–æ –ø–æ–ª–µ–π –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 // –ª–∏—à–Ω–µ–µ –ø–æ–ª–µ }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  Thus, <strong>whenever a composer sees an array, he will consider it as a composition of validator elements of this array in such a way that when one of them considers the value valid - the validation calculation stops - and the value is considered valid.</strong> </p><br><p>  As you can see, the composer considers a validator not only a function of a validator, but everything that can lead to a function of a validator. </p><br><table><thead><tr><th>  Validator Type </th><th>  Example </th><th>  How is perceived by the composer </th></tr></thead><tbody><tr><td>  validation function </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  just called on the required values </td></tr><tr><td>  object composition </td><td> <code>{ a: 'number' }</code> </td> <td>  creates a validator function for an object based on the specified field validators </td></tr><tr><td>  Variant composition </td><td> <code>['number', 'string']</code> </td> <td>  Creates a validator function to validate a value with at least one of the options </td></tr><tr><td>  Results of calling factory methods </td><td> <code>v.enum('male', 'female')</code> </td> <td>  Most factory methods return validation functions (with the exception of <code>v.rest</code> , which returns an object composition), so they are treated as normal validation functions. </td></tr></tbody></table><br><p>  All these validator variants are valid and can be used anywhere within the circuit in which the validator should be placed. </p><br><p>  As a result, the operation scheme is always the following: <code>v(schema)</code> returns the validation function.  This validation function is then invoked on specific values: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Have you had any accidents at a construction site? </h2><br><p>  <em>- not yet one</em> <br>  <em>- There will be!</em> </p><br><p>  It so happens that the data is invalid and we need to be able to determine the cause of invalidity. </p><br><p>  For this, the quartet library has an <em>explanation</em> mechanism.  It consists in the fact that in case the validator, whether internal or external, detects that the data being checked is invalid, he must send an <em>explanatory note</em> . </p><br><p>  For these purposes, the second argument of the composer validators <code>v</code> .  It adds a side effect of sending an <em>explanatory note</em> to the <code>v.explanation</code> array in the event of invalid data. </p><br><p>  An example, let us validate an array, and want to find out the numbers of all elements that are invalid and their value: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// –î–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è - –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω–∞ –ø—Ä–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ // —ç–ª–µ–º–µ–Ω—Ç–∞ –º–∞—Å—Å–∏–≤–∞ const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // –í–∏–¥–∏–º, —á—Ç–æ –µ—ë –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–≤. // –†–µ–∑—É–ª—å—Ç–∞—Ç –∂–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –±—É–¥–µ—Ç –ø–æ–º–µ—â—ë–Ω –≤ –º–∞—Å—Å–∏–≤ v.explanation // –ó–∞–¥–∞–¥–∏–º –≤–∞–ª–∏–¥–∞—Ç–æ—Ä –º–∞—Å—Å–∏–≤–∞ const arrValidator = v.arrayOf( v( 'number', // –≤–∞–ª–∏–¥–∞—Ç–æ—Ä —á–∏—Å–ª–∞ getExplanation // —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è "–∑–∞–ø–∏—Å–∫—É", –∏–ª–∏ —Å–∞–º–∞ "–∑–∞–ø–∏—Å–∫–∞" ) ) // –≤–∏–¥–∏–º, —á—Ç–æ –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–æ–º —ç–ª–µ–º–µ–Ω—Ç–∞ —è–≤–ª—è–µ—Ç—Å—è "–æ–±—ä—è—Å–Ω—è—é—â–∏–π" –≤–∞–ª–∏–¥–∞—Ç–æ—Ä // –í—Ç–æ—Ä—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä–∞ —è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ // –í—Ç–æ—Ä—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º –∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ —Ç–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏—è // –ù–æ –∏ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–º–µ—â–µ–Ω–æ –∫–∞–∫ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  As you can see, the choice of explanation depends on the task.  Sometimes it is not even necessary. </p><br><p>  Sometimes we need to do something with invalid fields.  In such cases, it makes sense to use the name of the invalid field as an <em>explanation</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] // –°–æ–æ–±—â–∞–µ–º –æ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö –ø–æ–ª—è—Ö console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid // –£–¥–∞–ª—è–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ –∏ –Ω–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –ø–æ–ª—è (—Å–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  With this explanation mechanism, you can implement any behavior associated with validation results. </p><br><p>  Anything can be an explanation: </p><br><ul><li>  an object containing the necessary information; </li><li>  function that corrects the error.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  the name of the invalid field, or the index of the invalid element; </li><li>  error code; </li><li>  and all that is enough for your imagination. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  What to do when it is not built? </h2><br><p>  Correcting validation errors is not a rare task.  For these purposes, the library uses validators with a side effect that remembers the location of the error and how to fix it. </p><br><ul><li>  <code>v.default(validator, value)</code> - returns a validator that remembers an invalid value, and at the time of calling <code>v.fix</code> - sets the default value </li><li>  <code>v.filter(validator)</code> - returns a validator that remembers an invalid value, and at the time of calling <code>v.fix</code> - removes this value from the parent </li><li>  <code>v.addFix(validator, fixFunc)</code> returns a validator that remembers an invalid value, and at the time <code>v.fix</code> is called, it calls fixFunc with parameters (value, {key, parent}, ...).  <code>fixFunc</code> - must mutate one of the pairs - to change the value </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">// –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —á–∏—Å–ª—É pos: v.and( v.default('number', 0), // –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —á–∏—Å–ª–æ - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å 0 v.addFix('non-negative', toPositive) // –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ - –ø–æ–º–µ–Ω—è—Ç—å –∑–Ω–∞–∫ ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() // –∏–ª–∏ —Å–∏–Ω–æ–Ω–∏–º v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  Housework still useful </h3><br><p>  There are also utility methods for validation related actions in this library: </p><br><table><thead><tr><th>  Method </th><th>  Result </th></tr></thead><tbody><tr><td> <a href="https://github.com/whiteand/quartet" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  In case of non-validity, throws a TypeError with the specified message. </td></tr><tr><td> <a href="https://github.com/whiteand/quartet" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Returns a new array (or dictionary object) with no invalid elements (fields). </td></tr><tr><td> <a href="https://github.com/whiteand/quartet" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Returns a new object with no invalid fields, given the object validator. </td></tr><tr><td> <a href="https://github.com/whiteand/quartet" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Returns the value if it is valid, otherwise it replaces it with the specified default value. </td></tr><tr><td> <a href="https://github.com/whiteand/quartet"><code>v.example</code></a> </td> <td>  Checks if these values ‚Äã‚Äãare appropriate for the schema.  If they do not fit, an error is thrown.  Provides documentation and testing schemes </td></tr></tbody></table><br><h2 id="rezultaty">  results </h2><br><p>  The tasks were solved in the following ways: </p><br><table><thead><tr><th>  Task </th><th>  Decision </th></tr></thead><tbody><tr><td>  Validation of data types </td><td>  Default named validators. </td></tr><tr><td>  Default values </td><td> <code>v.default</code> </td> </tr><tr><td>  Removing invalid parts </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> and <code>v.omitInvalidProps</code> . </td></tr><tr><td>  Easy to learn </td><td>  Simple validators, simple ways to compose them into complex validators. </td></tr><tr><td>  Code readability </td><td>  One of the goals of the library was to liken the validation schemes themselves </td></tr><tr><td>  validated objects. </td></tr><tr><td>  Ease of modification </td><td>  Having mastered the elements of compositions and using your own validation functions, changing the code is quite simple. </td></tr><tr><td>  Error message </td><td>  Explanation, in the form of an error message.  Or calculation of the error code based on explanations. </td></tr></tbody></table><br><h2 id="posleslovie">  Afterword </h2><br><p>  This solution was developed to quickly and easily create validator functions with the ability to embed custom validation functions.  Therefore, if any, any changes, criticism, improvement options from reading this article are welcome.  Thanks for attention. <br></p></div><p>Source: <a href="https://habr.com/ru/post/429916/">https://habr.com/ru/post/429916/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>