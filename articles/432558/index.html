<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural pattern "Visitor" ("Visitor") in the universe of "iOS" and "Swift"</title>
  <meta name="description" content="‚ÄúVisitor‚Äù is one of the behavioral patterns described in the ‚ÄúGang of Four‚Äù, ‚ÄúGoF‚Äù textbook that is ‚ÄúDesign Patterns: Elements of Reusable Object-Orie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="https://quick-geek.github.io/search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <section class="page js-page"><h1>Architectural pattern "Visitor" ("Visitor") in the universe of "iOS" and "Swift"</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://en.wikipedia.org/wiki/Visitor_pattern">‚ÄúVisitor‚Äù</a> is one of the behavioral patterns described in the <a href="https://en.wikipedia.org/wiki/Design_Patterns">‚ÄúGang of Four‚Äù, ‚ÄúGoF‚Äù</a> textbook that is <a href="https://en.wikipedia.org/wiki/Design_Patterns">‚ÄúDesign Patterns: Elements of Reusable Object-Oriented Software ")</a> . <br><a name="habracut"></a><blockquote>  In short, the template can be useful when it is necessary to be able to perform any similar actions on a group of objects of different types that are not related to each other.  Or, in other words, to extend the functionality of this series of types by some kind of operation, of the same type or having a single source.  In this case, the structure and implementation of extensible types should not be affected. </blockquote>  The easiest way to explain an idea is by example. <br><br>  <i>Immediately I would like to make a reservation that the example is fictional and composed for academic purposes.</i>  <i>Those.</i>  <i>This material is intended to introduce the reception of the PLO, and not to discuss highly specialized problems.</i> <br><br>  <i>I would also like to note that the code given in the examples was written in order to study the design technique.</i>  <i>I am aware of its (code) deficiencies and the possibilities of its improvement for use in real projects.</i> <br><br><h3>  Example </h3><br>  Suppose there is a subtype <code>UITableViewController</code> that uses several subtypes of <code>UITableViewCell</code> : <br><br><pre> <code class="plaintext hljs">class FirstCell: UITableViewCell { /**/ } class SecondCell: UITableViewCell { /**/ } class ThirdCell: UITableViewCell { /**/ } class TableVC: UITableViewController { override func viewDidLoad() { super.viewDidLoad() tableView.register(FirstCell.self, forCellReuseIdentifier: "FirstCell") tableView.register(SecondCell.self, forCellReuseIdentifier: "SecondCell") tableView.register(ThirdCell.self, forCellReuseIdentifier: "ThirdCell") } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { /**/ return FirstCell() /**/ return SecondCell() /**/ return ThirdCell() } }</code> </pre><br>  Suppose cells of different subtypes must have different heights. <br><br>  Of course, the height calculation can be placed directly in the implementation of each cell type.  But what if the height of the cell depends not only on its own type, but also on any external conditions?  For example, a cell type can be used in different tables with different heights.  In this case, we absolutely do not want the <code>UITableViewCell</code> subclasses to be aware of the needs of their ‚Äúsuperview‚Äù or ‚Äúview controller‚Äù. <br><br>  Then the height calculation can be done in the <code>UITableViewController</code> methods: either initialize the <code>UITableViewCell</code> together with the height value, or bring the <code>UITableViewCell</code> instance to a specific subtype and return different values ‚Äã‚Äãin the <code>tableView(_:heightForRowAt:)</code> method <code>tableView(_:heightForRowAt:)</code> .  But such an approach can also become inflexible and turn into a long sequence of ‚Äúif‚Äù operators or a cumbersome ‚Äúswitch‚Äù structure. <br><br><h4>  Solution of the problem using the template "Visitor" </h4><br>  <i>Of course, not only the template "Visitor" is able to solve this problem, but it is able to do it quite elegantly.</i> <br><br>  To do this, first, we will create a type, which will, in fact, be a ‚Äúvisitor‚Äù of cell types and an object whose responsibility lies only in calculating the height of the table cell: <br><br><pre> <code class="plaintext hljs">struct HeightResultVisitor { func visit(_ —Åell: FirstCell) -&gt; CGFloat { return 10.0 } func visit(_ —Åell: SecondCell) -&gt; CGFloat { return 20.0 } func visit(_ —Åell: ThirdCell) -&gt; CGFloat { return 30.0 } }</code> </pre><br>  The type is aware of each subtype used and returns the desired value for each of them. <br><br>  Secondly, each subtype of <code>UITableViewCell</code> should be able to ‚Äúaccept‚Äù a given ‚Äúvisitor‚Äù.  To do this, we will declare a protocol with such a ‚Äúreceiving‚Äù method, which will be implemented by all the types of cells used: <br><br><pre> <code class="plaintext hljs">protocol HeightResultVisitable { func accept(_ visitor: HeightResultVisitor) -&gt; CGFloat } extension FirstCell: HeightResultVisitable { func accept(_ visitor: HeightResultVisitor) -&gt; CGFloat { return visitor.visit(self) } } extension SecondCell: HeightResultVisitable { func accept(_ visitor: HeightResultVisitor) -&gt; CGFloat { return visitor.visit(self) } } extension ThirdCell: HeightResultVisitable { func accept(_ visitor: HeightResultVisitor) -&gt; CGFloat { return visitor.visit(self) } }</code> </pre><br>  Inside the <code>UITableViewController</code> subclass, the functionality can be used as follows: <br><br><pre> <code class="plaintext hljs">override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat { let cell = tableView.cellForRow(at: indexPath) as! HeightResultVisitable return cell.accept(HeightResultVisitor()) }</code> </pre><br><h4>  You can do better! </h4><br>  Most likely, we do not want to have such a hard-bound to a specific functionality code.  Perhaps we want to be able to add new functionality to our set of cells, but not only their height, but, say, the background color, the text inside the cell, etc., and not be tied to the return value type.  Here protocols with <code>associatedtype</code> ( <a href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html">‚ÄúProtocol with Associated Type‚Äù, ‚ÄúPAT‚Äù</a> ) will help us: <br><br><pre> <code class="plaintext hljs">protocol CellVisitor { associatedtype T func visit(_ cell: FirstCell) -&gt; T func visit(_ cell: SecondCell) -&gt; T func visit(_ cell: ThirdCell) -&gt; T }</code> </pre><br>  Its implementation to return the height of the cell: <br><br><pre> <code class="plaintext hljs">struct HeightResultCellVisitor: CellVisitor { func visit(_ cell: FirstCell) -&gt; CGFloat { return 10.0 } func visit(_ cell: SecondCell) -&gt; CGFloat { return 20.0 } func visit(_ cell: ThirdCell) -&gt; CGFloat { return 30.0 } }</code> </pre><br>  From the ‚Äúreceiving‚Äù side, it is sufficient to have only a general protocol and one single implementation for any ‚Äúvisitor‚Äù of this type.  Only the ‚Äúvisitor‚Äù parties will be aware of the different types of return values. <br><br>  The protocol for the ‚Äúreceiving visitor‚Äù (in the book ‚ÄúGoF‚Äù this side is referred to as ‚ÄúElement‚Äù) will take the form: <br><br><pre> <code class="plaintext hljs">protocol Visitable–°ell where Self: UITableViewCell { func accept&lt;V: CellVisitor&gt;(_ visitor: V) -&gt; VT }</code> </pre><br>  (There may be no restrictions for the implementing type here. But in this example, implementing this protocol by not subclassing <code>UITableViewCell</code> does not make sense.) <br><br>  And its implementations for <code>UITableViewCell</code> subtypes: <br><br><pre> <code class="plaintext hljs">extension FirstCell: Visitable–°ell { func accept&lt;V: CellVisitor&gt;(_ visitor: V) -&gt; VT { return visitor.visit(self) } } extension SecondCell: Visitable–°ell { func accept&lt;V: CellVisitor&gt;(_ visitor: V) -&gt; VT { return visitor.visit(self) } } extension ThirdCell: Visitable–°ell { func accept&lt;V: CellVisitor&gt;(_ visitor: V) -&gt; VT { return visitor.visit(self) } }</code> </pre><br>  And finally, use: <br><br><pre> <code class="plaintext hljs">override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat { let cell = tableView.cellForRow(at: indexPath) as! Visitable–°ell return cell.accept(HeightResultCellVisitor()) }</code> </pre><blockquote>  Thus, we will be able to create with the help of different implementations of the ‚Äúvisitor‚Äù, in general, almost anything, and the ‚Äúreceiving party‚Äù will not need anything to support the new functionality.  This party will not even be aware of what specifically for the ‚Äúguest‚Äù has been granted. </blockquote><h3>  Another example </h3><br>  Let's try to change the background color of the cell using a similar "visitor": <br><br><pre> <code class="plaintext hljs">struct ColorResultCellVisitor: CellVisitor { func visit(_ cell: FirstCell) -&gt; UIColor { return .black } func visit(_ cell: SecondCell) -&gt; UIColor { return .white } func visit(_ cell: ThirdCell) -&gt; UIColor { return .red } }</code> </pre><br>  An example of using this visitor: <br><br><pre> <code class="plaintext hljs">override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { cell.contentView.backgroundColor = (cell as! Visitable–°ell).accept(ColorResultCellVisitor()) }</code> </pre><br>  Something in this code should be embarrassing ... At the beginning, it was said that the "visitor" is able to add functionality to the class from outside.  So is it possible to ‚Äúhide‚Äù in it all the functionality of changing the background color of the cell, and not just just get the value from it?  Can.  Then the <code>associatedtype</code> here will take the value <a href="https://developer.apple.com/documentation/swift/void"><code>Void</code> (it is <code>()</code> - empty tuple)</a> : <br><br><pre> <code class="plaintext hljs">struct BackgroundColorSetter: CellVisitor{ func visit(_ cell: FirstCell) { cell.contentView.backgroundColor = .black } func visit(_ cell: SecondCell) { cell.contentView.backgroundColor = .white } func visit(_ cell: ThirdCell) { cell.contentView.backgroundColor = .red } }</code> </pre><br>  Using: <br><br><pre> <code class="plaintext hljs">override func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) { (cell as! Visitable–°ell).accept(BackgroundColorSetter()) }</code> </pre><br><br><h3>  Instead of conclusion </h3><br><br>  The pattern may be liked almost at a glance, however, it must be applied carefully.  Its appearance in code can often be a sign of more general flaws in architecture.  Perhaps you are trying to link things that should not be related.  Perhaps the added functionality is in one way or another to bring one level of abstraction above. <br><br><blockquote>  Anyway, almost any pattern has its advantages and disadvantages, and before using it you should always think and make a decision consciously.  Patterns are, on the one hand, a way to generalize programming techniques for easier reading and discussion of code.  On the other hand, there is a way to solve a problem (sometimes, artificially introduced).  And, of course, in any case, you should not fanatically bring the code to all known patterns just for the sake of the very fact of their use. </blockquote><br><br>  Perhaps I finished!  All beautiful code and fewer "bugs"! <br><br>  <b>My other articles about design patterns:</b> <br>  <a href="https://habr.com/ru/post/437614/">Architectural pattern "Iterator" ("Iterator") in the universe "Swift"</a> </div><p>Source: <a href="https://habr.com/ru/post/432558/">https://habr.com/ru/post/432558/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>