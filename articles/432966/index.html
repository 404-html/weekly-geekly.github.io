<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Encryption downloader for STM32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I would like to write about my experience in creating a bootloader for STM32 with firmware encryption. I am an individual developer, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <div class="page-header-logo-container"></div>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Encryption downloader for STM32</h1><div class="post__text post__text-html js-mediator-article">  In this article I would like to write about my experience in creating a bootloader for STM32 with firmware encryption.  I am an individual developer, so the code below may not meet any corporate standards. <br><br>  In the process, the following tasks were set: <br><br><ul><li>  Provide the user update the device from the SD card. </li><li>  Ensure control of the integrity of the firmware and exclude the recording of incorrect firmware in the memory of the controller. </li><li>  Provide firmware encryption to eliminate device cloning. </li></ul><br>  The code was written in Keil uVision using the stdperiph, fatFS and tinyAES libraries.  The experimental microcontroller was STM32F103VET6, but the code can be easily adapted to another STM controller.  Integrity control is provided by the CRC32 algorithm, the checksum is located in the last 4 bytes of the firmware file. <br><br>  The article does not describe the creation of the project, the connection of libraries, the initialization of the periphery and other trivial steps. <br><a name="habracut"></a><br>  First you need to decide what is the bootloader.  The STM32 architecture implies flat addressing of memory when Flash memory, RAM, peripheral registers, and everything else are in the same address space.  The loader is a program that starts to run when the microcontroller starts, checks whether it is necessary to update the firmware, if necessary, executes it, and starts the main program of the device.  This article will describe the update mechanism from the SD card, but you can use any other source. <br><br>  The firmware is encrypted using the AES128 algorithm and implemented using the tinyAES library.  It consists of only two files, one with the extension .c, the other with the extension .h, therefore problems with its connection should not arise. <br><br>  After creating the project, you should decide on the size of the loader and the main program.  For convenience, sizes should be selected multiple of the size of the microcontroller memory page.  In this example, the bootloader will occupy 64 Kb, and the main program will occupy the remaining 448 Kb.  The loader will be located at the beginning of the flash memory, and the main program immediately after the loader.  This should be indicated in the project settings in Keil.  Our bootloader starts at address 0x80000000 (it is from it that the STM32 starts executing the code after launch) and has a size of 0x10000, we indicate this in the settings. <br><br><img src="https://habrastorage.org/webt/ol/pp/vx/olppvx6lq6yafgjd8wnbkclxxbi.png"><br><br>  The main program will start at 0x08010000 and end at 0x08080000 for convenience, we will define with all addresses: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_START_ADDRESS 0x08010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_PROGRAM_END_ADDRESS 0x08080000</span></span></code> </pre> <br>  We will also add encryption keys and an AES initialization vector to the program.  These keys are best generated randomly. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_FW_KEY[] = {<span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAF</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> AES_IV[] = {<span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>};</code> </pre><br>  In this example, the entire procedure for updating the firmware is built as a finite state machine.  This allows the update process to display something on the screen, reset Watchdog and perform any other actions.  For convenience, let's define with the basic states of the automaton so as not to be confused by the numbers: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_START 5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_READ 1000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_WRITE 2000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_FINISH 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FW_ERROR 100000</span></span></code> </pre> <br>  After initialization of the peripherals, you need to check the need to update the firmware.  In the first state, an attempt is made to read the SD card and check for the presence of a file on it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t; <span class="hljs-comment"><span class="hljs-comment">/* –í—Ä–µ–º–µ–Ω–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_step; <span class="hljs-comment"><span class="hljs-comment">/* –ò–Ω–¥–µ–∫—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–æ–Ω–µ—á–Ω–æ–≥–æ –∞–≤—Ç–æ–º–∞—Ç–∞ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> fw_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* –ë—É—Ñ–µ—Ä –¥–ª—è —Å—á–∏—Ç–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞ –ø—Ä–æ—à–∏–≤–∫–∏ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> aes_buf[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* –ë—É—Ñ–µ—Ä –¥–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞ –ø—Ä–æ—à–∏–≤–∫–∏ —Ä–∞–≤–µ–Ω */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –ë—É—Ñ–µ—Ä—ã —Ä–∞–≤–Ω—ã —Ä–∞–∑–º–µ—Ä—É —Å—Ç—Ä–∞–Ω–∏—Ü—ã Flash-–ø–∞–º—è—Ç–∏*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> idx; <span class="hljs-comment"><span class="hljs-comment">/* –¢–µ–∫—É—â–∏–π –∞–¥—Ä–µ—Å –≤ –ø–∞–º—è—Ç–∏ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tbuf[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* –í—Ä–µ–º–µ–Ω–Ω—ã–π –±—É—Ñ–µ—Ä –¥–ª—è sprintf */</span></span> FATFS FS; <span class="hljs-comment"><span class="hljs-comment">/* –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ fatFS - —Ñ–∞–π–ª–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ */</span></span> FIL F; <span class="hljs-comment"><span class="hljs-comment">/* –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ fatFS - —Ñ–∞–π–ª */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ: <span class="hljs-comment"><span class="hljs-comment">/* –ß—Ç–µ–Ω–∏–µ –ø—Ä–æ—à–∏–≤–∫–∏ */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/* –ü—Ä–æ–±—É–µ–º —Å–º–æ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å SD-–∫–∞—Ä—Ç—É*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∞–π–ª —Å –ø—Ä–æ—à–∏–≤–∫–æ–π. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_READ | FA_OPEN_EXISTING) == FR_OK) { f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ */</span></span> CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/* –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–ø–ø–∞—Ä–∞—Ç–Ω—ã–π —Å—á–µ—Ç—á–∏–∫ CRC */</span></span> lcd_putstr(<span class="hljs-string"><span class="hljs-string">"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—à–∏–≤–∫–∏"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —ç–∫—Ä–∞–Ω */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–¥—Ä–µ—Å —á—Ç–µ–Ω–∏—è –Ω–∞ –Ω–∞—á–∞–ª–æ –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç - –∑–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–≥—Ä—É–∑—á–∏–∫ */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_FINISH;} <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ –Ω–µ—Ç SD-–∫–∞—Ä—Ç—ã - –∑–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–≥—Ä—É–∑—á–∏–∫ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Now we need to check the firmware for correctness.  Here, first comes the checksum verification code that runs when the file is finished reading, and then the reading itself.  Perhaps you should not write like that, write in the comments what you think about it.  Reading is done at 2 KB for the convenience of working with flash-memory, because  the STM32F103VET6 has a memory page size of 2 Kb. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ñ–∞–π–ª–∞ —Å –ø—Ä–æ—à–∏–≤–∫–æ–π */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* –í –ø—Ä–æ—Ü–µ—Å—Å–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞ —ç–∫—Ä–∞–Ω–µ, —Å–∫–æ–ª—å–∫–æ –±–∞–π—Ç —Å—á–∏—Ç–∞–Ω–æ */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tbuf, <span class="hljs-string"><span class="hljs-string">"–ü—Ä–æ–≤–µ—Ä–∫–∞: %d"</span></span>, idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ –ø—Ä–æ—á–∏—Ç–∞–∏ –≤–µ—Å—å —Ñ–∞–π–ª –ø—Ä–æ—à–∏–≤–∫–∏ */</span></span> { f_read(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/* –°—á–∏—Ç—ã–≤–∞–µ–º 4 –±–∞–π—Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Å—É–º–º—ã */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Å—á–∏—Ç–∞–Ω–Ω—ã–µ 4 –±–∞–π—Ç–∞ –≤ —Ä–µ–≥–∏—Å—Ç—Ä –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–∏—Ñ–µ—Ä–∏–π–Ω–æ–≥–æ –±–ª–æ–∫–∞ CRC */</span></span> CRC_CalcCRC(t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CRC_GetCRC() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç 0, —Ç–æ —Ñ–∞–π–ª –Ω–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–¥—Ä–µ—Å –∑–∞–ø–∏—Å–∏ –Ω–∞ –∞–¥—Ä–µ—Å –Ω–∞—á–∞–ª–∞ –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; f_lseek(&amp;F, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞ */</span></span> fw_step = FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">"–§–∞–π–ª –ø–æ–≤—Ä–µ–∂–¥–µ–Ω"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —ç–∫—Ä–∞–Ω */</span></span> fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —à–∞–≥—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } f_read(&amp;F, &amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), &amp;t); <span class="hljs-comment"><span class="hljs-comment">/* –°—á–∏—Ç—ã–≤–∞–µ–º 2 –ö–± –∏–∑ —Ñ–∞–π–ª–∞ –≤ –±—É—Ñ–µ—Ä */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(t != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)) <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å—á–∏—Ç–∞—Ç—å */</span></span> { lcd_putstr(<span class="hljs-string"><span class="hljs-string">"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fw_step = FW_ERROR; <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —à–∞–≥—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å—á–∏—Ç–∞–Ω–Ω—ã–π –±–ª–æ–∫ –ø—Ä–æ—à–∏–≤–∫–∏ */</span></span> AES_CBC_decrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(aes_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –±–ª–æ–∫ –≤ —Ä–µ–≥–∏—Å—Ç—Ä CRC */</span></span> { CRC_CalcCRC(aes_buf[t]); <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø–∏—Å—å –≤–µ–¥–µ–º –ø–æ 4 –±–∞–π—Ç–∞ */</span></span> } idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/* –°–¥–≤–∏–≥–∞–µ–º –∞–¥—Ä–µ—Å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–µ 2 –ö–± */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Now, if the firmware is not damaged, then you need to read it again, but this time it is already recorded in Flash - memory. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_READ + <span class="hljs-number"><span class="hljs-number">20</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Flash Firmware { /* –í –ø—Ä–æ—Ü–µ—Å—Å–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞ —ç–∫—Ä–∞–Ω–µ, —Å–∫–æ–ª—å–∫–æ –±–∞–π—Ç –∑–∞–ø–∏—Å–∞–Ω–æ */ sprintf(tbuf, "–ó–∞–ø–∏—Å—å: %d", idx - MAIN_PROGRAM_START_ADDRESS); lcd_putstr(tbuf, 4, 2); if (idx &gt; MAIN_PROGRAM_END_ADDRESS) /* –ö–æ–≥–¥–∞ –∑–∞–ø–∏—Å–∞–ª–∏ –≤—Å—é –ø—Ä–æ—à–∏–≤–∫—É */ { lcd_putstr("–ì–æ—Ç–æ–≤–æ", 7, 3); /* –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —ç–∫—Ä–∞–Ω */ f_unlink("FIRMWARE.BIN"); /* –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –ø—Ä–æ—à–∏–≤–∫–∏ —Å SD-–∫–∞—Ä—Ç—ã */ fw_step = FW_FINISH; /* –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–≥—Ä—É–∑—á–∏–∫ */ break; } f_read(&amp;F, &amp;fw_buf, sizeof(fw_buf), &amp;t); /* –°—á–∏—Ç—ã–≤–∞–µ–º –±–ª–æ–∫ 2 –ö–± */ if(t != sizeof(fw_buf)) /* –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å—á–∏—Ç–∞—Ç—å */ { lcd_putstr("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è", 3, 3); /* –í—ã–≤–æ–¥–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —ç–∫—Ä–∞–Ω */ fw_step = FW_ERROR; /* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —à–∞–≥—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è */ break; } /* –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å—á–∏—Ç–∞–Ω–Ω—ã–π –±–ª–æ–∫ –ø—Ä–æ—à–∏–≤–∫–∏ */ AES_CBC_decrypt_buffer((uint8_t*)&amp;aes_buf, (uint8_t *)&amp;fw_buf, sizeof(fw_buf), AES_FW_KEY, AES_IV); FLASH_Unlock(); /* –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º FLash-–ø–∞–º—è—Ç—å –Ω–∞ –∑–∞–ø–∏—Å—å */ FLASH_ErasePage(idx); /* –°—Ç–∏—Ä–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–∞–º—è—Ç–∏ */ for(t=0;t&lt;sizeof(aes_buf);t+=4) /* –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ—à–∏–≤–∫—É –ø–æ 4 –±–∞–π—Ç–∞ */ { FLASH_ProgramWord(idx+t, aes_buf[t/4]); } FLASH_Lock(); /* –ë–ª–æ–∫–∏—Ä—É–µ–º –ø—Ä–æ—à–∏–≤–∫—É –Ω–∞ –∑–∞–ø–∏—Å—å */ idx+=sizeof(fw_buf); /* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ */ break; }</span></span></code> </pre><br>  Now for beauty, we will create states for error handling and successful updating: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_ERROR: { <span class="hljs-comment"><span class="hljs-comment">/* –ú–æ–∂–Ω–æ —á—Ç–æ-—Ç–æ —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∏ –æ—à–∏–±–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_FINISH: { ExecMainFW(); <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –î–∞–ª—å–Ω–µ–π—à–∏–π –∫–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω –Ω–µ –±—É–¥–µ—Ç */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  The startup function of the main ExecMainFW () program is worth considering in more detail.  Here she is: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecMainFW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–¥—Ä–µ—Å –ø–µ—Ä–µ—Ö–æ–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏, –∞–¥—Ä–µ—Å –∫–æ—Ç–æ—Ä–æ–π —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* +4 –±–∞–π—Ç–∞ –ø–æ—Ç–æ–º—É, —á—Ç–æ –≤ —Å–∞–º–æ–º –Ω–∞—á–∞–ª–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –≤–µ–∫—Ç–æ—Ä –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> jumpAddress = *(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) (MAIN_PROGRAM_START_ADDRESS + <span class="hljs-number"><span class="hljs-number">4</span></span>); pFunction Jump_To_Application = (pFunction) jumpAddress; <span class="hljs-comment"><span class="hljs-comment">/*–°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å—é –ø–µ—Ä–∏—Ñ–µ—Ä–∏—é –Ω–∞ APB1 */</span></span> RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB1RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*–°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å—é –ø–µ—Ä–∏—Ñ–µ—Ä–∏—é –Ω–∞ APB2 */</span></span> RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; RCC-&gt;APB2RSTR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; RCC-&gt;APB1ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–∫–ª—é—á–∞–µ–º –≤—Å—é –ø–µ—Ä–∏—Ñ–µ—Ä–∏—é –Ω–∞ APB1 */</span></span> RCC-&gt;APB2ENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–∫–ª—é—á–∞–µ–º –≤—Å—é –ø–µ—Ä–∏—Ñ–µ—Ä–∏—é –Ω–∞ APB2 */</span></span> RCC-&gt;AHBENR = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–∫–ª—é—á–∞–µ–º –≤—Å—é –ø–µ—Ä–∏—Ñ–µ—Ä–∏—é –Ω–∞ AHB */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Ç–∞–∫—Ç–æ–≤–∞–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ HSI*/</span></span> RCC_DeInit(); <span class="hljs-comment"><span class="hljs-comment">/* –í—ã–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è */</span></span> __disable_irq(); <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ–Ω–æ—Å–∏–º –∞–¥—Ä–µ—Å –≤–µ–∫—Ç–æ—Ä–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π */</span></span> NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ–Ω–æ—Å–∏–º –∞–¥—Ä–µ—Å —Å—Ç—ç–∫–∞ */</span></span> __set_MSP(*(__IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*) MAIN_PROGRAM_START_ADDRESS); <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –æ—Å–Ω–æ–≤–Ω—É—é –ø—Ä–æ–≥—Ä–∞–º–º—É */</span></span> Jump_To_Application(); }</code> </pre> <br>  Immediately after launching the startup file, everything was re-initialized, so the main program should again set the pointer to the interrupt vector within its address space: <br><br><pre> <code class="cpp hljs">__disable_irq(); NVIC_SetVectorTable(NVIC_VectTab_FLASH, MAIN_PROGRAM_START_ADDRESS); __enable_irq();</code> </pre><br>  In the draft of the main program you need to specify the correct addresses: <br><br><img src="https://habrastorage.org/webt/xc/o5/41/xco541o-b7_wgzrdvoovdqtpqvu.png"><br><br>  This is the whole update procedure.  The firmware is checked for correctness and encrypted, all assigned tasks are completed.  In the event of a power loss during the update process, the device will, of course, become bogged down, but the bootloader will remain intact and the upgrade procedure can be repeated.  For critical situations, you can block the page in which the loader is located via Option bytes. <br><br>  However, in the case of an SD card, you can organize one pleasant convenience for yourself in the bootloader.  When testing and debugging a new firmware version is completed, you can force the device itself to encrypt and unload the finished firmware onto an SD card according to some special condition (for example, a button or jumper inside).  In this case, it remains only to remove the SD card from the device, insert it into the computer and put the firmware on the Internet to the joy of the users.  Let's do this in the form of two more states of the finite state machine: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_mount(&amp;FS, <span class="hljs-string"><span class="hljs-string">""</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span>) == FR_OK) <span class="hljs-comment"><span class="hljs-comment">/* –ü—Ä–æ–±—É–µ–º —Å–º–æ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å SD-–∫–∞—Ä—Ç—É*/</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* –ü—Ä–æ–±—É–µ–º —Å–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(f_open(&amp;F, <span class="hljs-string"><span class="hljs-string">"FIRMWARE.BIN"</span></span>, FA_WRITE | FA_CREATE_ALWAYS) == FR_OK) { CRC_ResetDR(); <span class="hljs-comment"><span class="hljs-comment">/* –°–±—Ä–∞—Å—ã–≤–∞–µ–º –±–ª–æ–∫ CRC */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–¥—Ä–µ—Å —á—Ç–µ–Ω–∏—è –Ω–∞ –Ω–∞—á–∞–ª–æ –æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã */</span></span> idx = MAIN_PROGRAM_START_ADDRESS; fw_step = FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —à–∞–≥—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {fw_step = FW_ERROR;} <span class="hljs-comment"><span class="hljs-comment">/* –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —à–∞–≥—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–∫–∏ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FW_WRITE + <span class="hljs-number"><span class="hljs-number">10</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx &gt; MAIN_PROGRAM_END_ADDRESS) <span class="hljs-comment"><span class="hljs-comment">/* –ï—Å–ª–∏ –≤—ã–≥—Ä—É–∑–∏–ª–∏ –≤—Å—é –ø—Ä–æ—à–∏–≤–∫—É */</span></span> { t = CRC_GetCRC(); f_write(&amp;F, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t), &amp;idx); <span class="hljs-comment"><span class="hljs-comment">/* –î–æ–ø–∏—Å—ã–≤–∞–µ–º –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é —Å—É–º–º—É */</span></span> f_close(&amp;F); <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–∫—Ä—ã–≤–∞–µ–º —Ñ–∞–π–ª, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à */</span></span> fw_step = FW_FINISH; <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞—Ä—É–∑—á–∏–∫ */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* –°—á–∏—Ç—ã–≤–∞–µ–º 2 –ö–± –ø—Ä–æ—à–∏–≤–∫–∏ –∏–∑ Flash-–ø–∞–º—è—Ç–∏ –≤ –±—É—Ñ–µ—Ä */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;fw_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *)idx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(t=<span class="hljs-number"><span class="hljs-number">0</span></span>;t&lt;NELEMS(fw_buf);t++) <span class="hljs-comment"><span class="hljs-comment">/* –í—ã—á–∏—Å–ª—è–µ–º CRC –¥–ª—è —Å—á–∏—Ç–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞ */</span></span> { CRC_CalcCRC(fw_buf[t]); } <span class="hljs-comment"><span class="hljs-comment">/* –®–∏—Ñ—Ä—É–µ–º –ø—Ä–æ—à–∏–≤–∫—É */</span></span> AES_CBC_encrypt_buffer((<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*)&amp;aes_buf, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)&amp;fw_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf), AES_FW_KEY, AES_IV); <span class="hljs-comment"><span class="hljs-comment">/* –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π –±–ª–æ–∫ –≤ —Ñ–∞–π–ª */</span></span> f_write(&amp;F, &amp;aes_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(aes_buf), &amp;t); idx+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(fw_buf); <span class="hljs-comment"><span class="hljs-comment">/* –°–¥–≤–∏–≥–∞–µ–º –∞–¥—Ä–µ—Å —Å—á–∏—Ç—ã–≤–∞–µ–º–æ–≥–æ –±–ª–æ–∫–∞ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  That's all that I wanted to tell.  At the end of the article I would like to wish you, after creating such a bootloader, not to forget to include the protection from reading the microcontrol memory in Option bytes. <br><br><h4>  Links </h4><br>  <a href="https://github.com/kokke/tiny-AES-c">tinyAES</a> <br>  <a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFS</a> </div><p>Source: <a href="https://habr.com/ru/post/432966/">https://habr.com/ru/post/432966/</a></p>
<section class="navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><p>Waiting for the list form <a href="../../index.html">here</a>...</p></nav>
</section>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>
</body>

</html>